## 硬链接和软连接

https://blog.csdn.net/mxgsgtc/article/details/82810181

https://blog.csdn.net/qq_42294367/article/details/83268916

https://blog.csdn.net/hairetz/article/details/4168296

#### 索引节点

linux 系统，为每个**文件分配**一个**编号**（inode），但是理解上可以**理解**成一个**指针**，通过这个 inode 可以找到文件。

#### 硬链接

硬链接可以认为是一个指针，指向**文件索引节点**（inode）的指针 。

b 是 a 的硬链接，那么 a 和 b 指向同一个 inode。

![](C:\Users\78478\Desktop\review\20181022105251701.png)

所以这么理解，本来只有 a （路径名）代表 a 文件，现在 b 路径也代表 a 文件。（有点绕口）

***硬连接的作用是允许一个文件拥有多个有效路径名*** 。

***文件真正删除的条件是与之相关的所有硬连接文件均被删除。***

#### 软连接

软连接指向的是和源文件**不同**的 inode，inode 指向的内容是源文件的路径。

![](C:\Users\78478\Desktop\review\20181022103844736.png)

## 多进程多线程的区别

| 维度           | 多进程                                                       | 多线程                                 | 总结     |
| -------------- | ------------------------------------------------------------ | -------------------------------------- | -------- |
| 数据共享、同步 | 数据是分开的:共享复杂，需要用IPC;同步简单                    | 多线程共享进程数据：共享简单；同步复杂 | 各有优势 |
| 内存、CPU      | 占用内存多，切换复杂，CPU利用率低                            | 占用内存少，切换简单，CPU利用率高      | 线程占优 |
| 创建销毁、切换 | 创建销毁、切换复杂，速度慢                                   | 创建销毁、切换简单，速度快             | 线程占优 |
| 编程调试       | 编程简单，调试简单                                           | 编程复杂，调试复杂                     | 进程占优 |
| 可靠性         | 进程间不会相互影响                                           | 一个线程挂掉将导致整个进程挂掉         | 进程占优 |
| 分布式         | 适应于多核、多机分布 ；如果一台机器不够，扩展到多台机器比较简单 | 适应于多核分布                         | 进程占优 |

# 进程间切换与线程间切换的区别

https://www.cnblogs.com/lfri/p/12597297.html

最重要的区别就是**虚拟内存切换**的区别，这个也是进程消耗比线程切换消耗多的原因。

为什么虚拟内存切换损耗很大？

因为往往页表查询是一个很慢的过程，所以通常会用缓存也就是 TLB（页表缓冲，**快表**）来加速查询，而进程切换的时候，这些**缓冲统统失效**了。

线程切换不会导致 TLB 失效。

## 僵尸进程，孤儿进程，守护进程

#### 僵尸进程

unix 在子进程退出的时候，**不会**完全**释放**子进程所有的信息，而是**保留一部分信息**，让父进程可以获取子进程退出的信息。

所以，父进程必须调用 **wait/waitpid**，不然子进程这个信息会一直保留，**进程号会一直被占用**，而系统的进程号是有限的，如果有大量的僵尸进程，**会导致操作系统无法生成新的进程**。这就是僵尸进程的危害。

#### 孤儿进程

父进程退出，子进程没有退出，那么子进程会挂到 init 进程下面，没有危害。

#### 守护进程

就是一种后台进程，独立于终端，周期性执行某些任务。

## 进程描述符

进程描述符就是 task_struct，以及叫做 pcb，同一个东西

## 进程通信的优缺点

可以看到一种补充关系

https://zhuanlan.zhihu.com/p/135395279

https://blog.csdn.net/m0_37907797/article/details/103188294

## 使用ET和LT的区别

#### ET触发

https://blog.csdn.net/peng314899581/article/details/89234888

*要特别注意，当连接断开时是会触发可读可写事件的，就是从**可读**变成**不可读**。*

1. 文件描述符就绪的时候，也就是缓冲区从空变到有数据的时候，触发一次。
2. 连接断开的时候也会触发一次。

#### 场景使用

LT：水平触发，效率会低于ET触发，尤其在大并发，大流量的情况下。但是LT对代码编写要求比较低，不容易出现问题。LT模式服务编写上的表现是：只要有数据没有被获取，内核就不断通知你，因此不用担心事件丢失的情况。

ET：边缘触发，效率非常高，在并发，大流量的情况下，**会比LT少很多epoll的系统调用**，因此效率高。但是对编程要求高，需要细致的处理每个请求，否则容易发生丢失事件的情况。

#### 怎么理解 epoll 的可写事件

好像没有用到可写事件，实际上是有的，只不过我们平时发的数据量比较小，想象一下，如果数据量特别大，例如几个 G，你觉得 tcp 会允许你一次发送这么多吗？内存受得了吗

https://www.zhihu.com/question/22840801

#### ET写事件的触发

1. 写了之后，fd 满了，导致不能再继续写，等到 fd 中的数据被读走了，又可以继续写了。
2. 当连接断开的时候，从可写变成不可写又会触发一次。

## 阻塞和就绪

这两个概念长时间弄混了，其实压根不一样，就绪就是我本来就在运行，只不过 cpu 给我的时间到了，所以我暂时不能不能运行，但是我所有的资源都还是原来那样，这种并不是阻塞。

阻塞是我时间片还在，但是我执行了某些操作，导致我现在被阻塞了。

总之一句话，就绪就是时间片轮不到了（不关乎你运行了什么），而阻塞是我执行某些操作导致了阻塞。

## 栈和堆的区别

https://blog.csdn.net/yingms/article/details/53188974

## 共享内存的实现

 mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。 

**注意**：这个文件是一个实现了文件系统接口的内存。

https://blog.csdn.net/Al_xin/article/details/38602093

 一句话共享内存的原理就是**同一块物理内存被映射到进程A，B各自的进程地址空间。** 