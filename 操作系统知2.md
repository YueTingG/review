## 调度过程/进程切换/上下文切换

1. 保存处理机现场信息：把 pc 寄存器和 ss，esp 存储到 PCB 中，其实就是存储到 task_struct 的 thread 字段中（linux 的实现）。

2. 按照某种算法取进程：从就绪队列中取一个进程，改变其状态并分配处理机资源 

3. 把处理机分配给进程：按照PCB的信息在处理器相应的寄存器中转入信息，并把处理机控制权赋予进程。

## task_struct 和 pcb

task_struct 就是 linux 中 PCB 的实现，PCB 是一个广泛的概念，操作系统层面上的概念。

## 用户态内核态切换的过程 / 中断的过程/系统调用的过程

步骤主要包括：

#### 1、从当前进程的描述符中提取其内核栈的ss0及esp0信息。

*解释*：准确来讲，按照我查到的资料，是从 TSS （任务状态段）获取到 ss0 和 esp0。

什么是 TSS？

TSS 就是任务状态段，你只需要明白本来应该是一个进程一个 TSS ，但是在 linux 的实现当中每个CPU一个 ，里面存放着 ss0 和esp0。

什么是 ss0 和 esp0？

ss0 是 内核态堆栈段，理解上可以理解为 ss0 指向内核栈，而esp0  是栈指针。

#### 2、使用ss0和esp0指向的内核栈将当前进程的cs,eip (pc: cs+epi的实现)，eflags，ss, esp信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。

解释一下：eip 和 cs 可以理解成就是pc寄存器的实现，我们通常说的 pc 只是一种概念，这里epi 和 cs 就是具体的实现。

ss 就是用户进程栈，每个进程都有自己的栈，这个在进程空间分布中，esp就是进程栈的栈顶指针。

cs  代码段寄存器，其实我不是很理解这个“段”，跟分段或者进程空间分布中的段是什么关系。

#### 3、将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。

## 进程切换和系统调用的一点区别

这里不太清楚，但是一些资料上显示，进程切换保存现场的时候，是把数据存储在**PCB（或者讲是用户的栈，总之根据代码可以看出是存储到 task_struct 的 thread 字段里面）**里面的。

而系统调用是存储到**内核栈**上面了。

## 进程和线程的区别

先回答概念，再答区别:

<u>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。</u>

<u>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位</u>。

## 分页

逻辑地址到物理地址的映射过程

1. 提取页号，即逻辑地址最左的n位

2. 以这个页号为索引，查找该进程页表中相应的帧号k

3. 该帧的起始物理地址为k*2^m,被访问字节的物理地址是这个数加上偏移量

![img](https://img-blog.csdn.net/20130430152724381)

举个例子

腾讯今年的实习生笔试的某个选择题

 ![img](https://img-blog.csdn.net/20130430155810249) 

 根据上面的三个步骤可以很容易得到结果：物理地址 = 3 * 8 * 1024 + 9612 % 8192 = 25996 

## 分段

*具体参考资料 <Java源码圈 PDF书籍压缩包>，我百度网盘里面有*

#### 到底什么是分段？

从虚拟地址上来讲，按照分页的思想内存是连续的（虚拟地址连续），物理是不连续的，但是现在我连虚拟地址都是不连续的，但是这个不连续不是指断断续续的，而是划分成一段一段。

即本来虚拟地址可能是1~100，现在我把1~25取出来划分成一段，25~30划分成另外一段...这就是分段。

注意我这里分段最大的特点就是段长不需要统一（1~25和25~30的长度不一样，按照分类去划分）。

逻辑地址到物理地址的映射过程

#### 划分过程

1. 提取段号，即逻辑地址最左的n位s

2. 以这个段号为索引，查找该进程段表中该段的起始物理地址

3. 最右m位表示偏移量，偏移量和段长度比较，如果偏移量大于该长度，则该地址失效

4. 物理地址为该段的起始物理地址加上偏移量的和



![img](https://img-blog.csdn.net/20130430152743662)

## IPC

没多大用，但是看看逻辑： https://mp.weixin.qq.com/s/5CbYGrylSKx1JwtOiW3aOQ 

有些有用，有些没有 https://www.jianshu.com/p/c1015f5ffa74 

### 管道

在了解管道的本质前，最好先了解以下vfs（虚拟文件系统）

 https://developer.ibm.com/tutorials/l-linux-filesystem/ 

 https://blog.csdn.net/weixin_39278265/article/details/88839027 

#### 本质

实际上管道的设计也是遵循UNIX的“一切皆文件”设计原则的，它本质上就是一个文件（这句话不太合理，本质是内存，实现了文件系统的对象而已，所以算作一个文件系统）。**Linux系统直接把管道实现成了一种文件系统，借助VFS给应用程序提供操作接口**。

虽然实现形态上是文件，但是管道本身并不占用磁盘或者其他外部存储的空间。在Linux的实现上，它占用的是内存空间。所以，**Linux上的管道就是一个操作方式为文件的内存缓冲区**。

#### 实现原理

同其他真正的文件系统（ext3、ext4等）一样，**都实现VFS中的四种主要对象：super_block、inode、dentry和文件对象file** 。

在Linux中，管道是通过指向同一个临时VFS inode的两个file数据结构来实现的，此VFS inode指向内存中的一个物理页面。 

 ![img](http://net.pku.edu.cn/~yhf/lyceum/linuxK/ipc/pipes.gif) 

#### 结论

它确实是一个文件，它实现了文件的定义和各种接口，但是本质上它是以内存的方式存在的，所以它是一种特殊的文件，可以理解为以内存的存在方式实现了文件接口。

一个管道实际上就是个只存在于内存中的文件。

#### 为什么说只有父子能用

因为管道是一种文件系统，在fork的时候父子进程能够共享资源，这里的资源就包括文件操作符fd，所以只有父子能够共享。

#### 注意

管道不能是半双工的，要想进程一边写一边读，必须要两个管道。

### 有名管道

#### 与匿名管道的不同

 FIFO不同于无名管道之处在于它提供了一个路径名与之关联，**以FIFO的文件形式存在于文件系统中**，这样，**即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信** 

#### 读写规则

 http://blog.chinaunix.net/uid-26833883-id-3227144.html 

**记住有名管道读取和写入很麻烦就对了**

#### 创建

管道一般是由一个进程创建的，这里需要提一句，为什么我们说“消息队列独立于进程”，这里特指跟管道的比较，管道从设计上来讲是文件系统（本质是内存），那你是一个文件系统又是一个进程创建的，那么你就算是一个进程的资源，可以就是跟进程绑定在一块了，你当然不能说“管道独立于进程”。

那么父进程就可以对这个资源进行共享，特别是跟自己的子进程共享，这也是匿名管道的关键，有名管道之所以摆脱了这个限制，关键是提供了一个路径，别的进程可以通过这个路径访问这个资源。

### 信号

#### 信号生命周期和处理流程

 （1）信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；
 （2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。
 （3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。

#### 大白话

基本是这样的，得有个信号注册函数，指名收到某某信号的时候，你的处理函数是什么。

也就是程序接收到对应信号的时候就会执行对应的函数，至于怎么接受的你可以理解为自动接收的，至于信号的产生可以是人为产生也就是ctrl+c，也可以调用一个函数产生。

 https://www.runoob.com/cplusplus/cpp-signal-handling.html 看一下里面signal函数的例子就明白了。

### 消息队列

#### 实现

消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示

#### 与管道的不同

与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。

另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。

独立于进程。

### 共享内存

#### 快的原因

因为不需要io，直接读写内存，就像你操作普通变量一样，只不过现在操作的变量在共享的内存里面。

 https://www.cnblogs.com/linuxbug/p/4882776.html 

#### 其他方面需要后序补充

### **信号量** 

#### 本质

可以说本质就是一个非负变量，只不过每次访问这个变量的时候都是原子操作，举个例子，如果信号为1，那么我可以访问临界区，并且把信号量变成0，如果信号量为0，则不能访问临界区。

每次访问临界区之前先访问一下这个信号量。

### 套接字

没啥好说的，用得太多了，tcp/udp

## 函数调用

 https://segmentfault.com/a/1190000007977460 

 https://www.jianshu.com/p/c7154146bdef 

有时间再总结

## 内核栈

 https://blog.csdn.net/yangkuanqaz85988/article/details/52403726 

#### 