## 3.MySQL高并发解决方案？

1）代码中sql语句优化

2）数据库字段优化，索引优化

3）加缓存，redis/memcache等

4）主从，读写分离

5）分区表

6）垂直拆分，解耦模块

**垂直拆分**： 将一张表的字段拆分为主表以及扩展表，使用频次较高的字段在一张表，其余的在一张表 

常我们按以下原则进行垂直拆分:

1. 把不常用的字段单独放在一张表;
2. 把text，blob等大字段拆分出来放在附表中;
3. 经常组合查询的列放在一张表中;

7）水平切分

**水平分表**

将一张表中的记录拆分到多个结构相同的表中，一般按照表中的某个字段的关键字进行数字取模，余数就是应该存放的表位置。

除了取模，还有按照ID范围，也可以按照时间范围；

对于分完表之后的数据进行查询的时候，一般不使用join，而是使用两次查询。

拆分举例：

通常情况下，我们使用取模的方式来进行表的拆分;比如一张有400W的用户表`users`，为提高其查询效率我们把其分成4张表`users1，users2，users3，users4`
通过用ID取模的方法把数据分散到四张表内`Id%4+1 = [1,2,3,4]` 

## 4.索引实现方式有哪些？

b+树，hash

## 5.索引失效的情况？

 https://juejin.im/post/5df8830cf265da339565e184#heading-8 

#### 1. where语句中包含or时，可能会导致索引失效

~~使用or并不是一定会使索引失效，你需要看or左右两边的查询列是否命中相同的索引~~。

 避免在 where 子句中使用 **or** 来连接条件, 因为如果**俩个字段中有一个没有索引**的话, 引擎会放弃索引而产生全表扫描 

#### 2. where语句中索引列使用了负向查询，可能会导致索引失效

负向查询包括：NOT、!=、<>（不等于）、!<、!>、NOT IN、NOT LIKE等。

其实负向查询并不绝对会索引失效，这要看MySQL优化器的判断，全表扫描或者走索引哪个成本低了。

#### 3. 索引字段可以为null，使用is null或is not null时，可能会导致索引失效(暂时存疑)

#### 4. 在索引列上使用内置函数，一定会导致索引失效

#### 6. like通配符可能会导致索引失效

#### 7. 联合索引中，where中索引列违背最左匹配原则，一定会导致索引失效

## 6.索引的分类？

#### 从数据结构角度

1、B+树索引(O(log(n)))：关于B+树索引，可以参考 [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

2、hash索引：
a 仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询
b 其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引
c 只有Memory存储引擎显示支持hash索引

3、FULLTEXT索引（现在MyISAM和InnoDB引擎都支持了）（还不懂）

4、R-Tree索引（用于对GIS数据类型创建SPATIAL索引）（还不懂）

#### 从物理存储角度

1、聚集索引（clustered index）

2、非聚集索引（non-clustered index）

### 从逻辑角度

PRIMARY KEY 主键索引

INDEX 普通索引

UNIQUE 唯一索引

FULLTEXT 全文索引 （全文索引不是指在全部行上加索引，索引都是在某个字段起作用，这里也一样，通过在某个字段上加索引，那么可以实现更加快速的“模糊查询”，暂时可以这么理解，当你某个字段的数据量很大的时候，使用模糊查询速度非常慢，当时使用全文索引的话，速度能快很多，所以全文索引也是一种起作用在某个字段上的索引）

组合索引（较特殊）

## redis zset 数据结构

redis的review

## redis的高可用

 https://juejin.im/post/5b7d226a6fb9a01a1e01ff64#heading-27 

## 哨兵之间是怎么互相发现的

看redis的review

## 索引用b+树比b树的好处？

## group by 和order by走不走索引

如果where中有索引字段，并且group by后面是同样的索引字段，那么是走索引的，因为mysql是先查出来再去排序的，关键就是查出来之后是不是已经有序了，如果查出来之后已经有序了，那么不需要排序，会快很多

## 虚拟内存

维基百科的答案

主要就是通过映射，让程序以为内存连续，其实有可能是分开的物理内存，甚至有些内存在磁盘上。

标准答案：

**虚拟内存**是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的[物理内存](https://zh.wikipedia.org/wiki/物理内存)（例如[RAM](https://zh.wikipedia.org/wiki/隨機存取記憶體)）的使用也更有效率。

注意：**虚拟内存**不只是“用磁盘空间来扩展物理内存”的意思——这只是扩充[内存级别](https://zh.wikipedia.org/wiki/記憶體階層)以使其包含[硬盘驱动器](https://zh.wikipedia.org/wiki/硬盘驱动器)而已。把内存扩展到磁盘只是使用虚拟内存技术的一个结果，它的作用也可以通过[覆盖](https://zh.wikipedia.org/wiki/覆盖_(编程))或者把处于不活动状态的程序以及它们的数据全部交换到磁盘上等方式来实现。对虚拟内存的定义是基于对[地址空间](https://zh.wikipedia.org/wiki/地址空间)的重定义的，即把地址空间定义为“连续的虚拟内存地址”，以借此“欺骗”程序，使它们以为自己正在使用一大块的“连续”地址。

## epoll的特点，实现

数据结构：

红黑树 rbr ：存储所有被监听的事件结点（实际例子来讲就是一个个socket文件描述符）

双向链表 rdlist ：存储事件发生时的文件描述符

等待队列：进程的等待队列

当事件发生时，会把事件结点添加进rdlist，还会通过该事件的回调函数（网卡绑定了回调函数）唤醒eventpoll队列中的进程。

 ![image_1c8flp0eq1eeevtk14731f8p11889.png-88.6kB](http://static.zybuluo.com/myecho/8rcvy33m7yyke8fexvestrvb/image_1c8flp0eq1eeevtk14731f8p11889.png) 

连接不能全信，像socket中有等待队列就是一件需要确认的事情，但是讲得循序渐进，值得一看：https://zhuanlan.zhihu.com/p/64138532 

## dns解析过程？解析用tcp还是udp？

一般的地址应该为：www.baidu.com.root，最后应该是有root，这个就叫做根，大家都一样所以省略，然后是com是顶级域名，然后是baidu的次级域名，[有关域名的讲解](http://www.ruanyifeng.com/blog/2016/06/dns.html)

查询的过程，分成递归查询和迭代查询，如下图所示，[解析过程](https://zhuanlan.zhihu.com/p/38499577) 一级一级往下查，一开始客户端访问本地dns是递归，后面都是迭代查询。





 ![img](https://pic1.zhimg.com/80/v2-a8f29e5de931a58e10d72c8b1020dc68_1440w.jpg) 

域名查询时采用udp，区域传送时采用tcp

**DNS区域传送**（**DNS zone transfer**）指的是一台备用服务器使用来自主服务器的数据刷新自己的域（zone）数据库。这为运行中的DNS服务提供了一定的冗余度，其目的是为了防止主的域名服务器因意外故障变得不可用时影响到整个域名的解析。 

区域传送可以理解成主从复制，从服务器要更新数据，数据量庞大，这时候就要确保数据不丢失。

## socket服务端和客户端分别有哪些方法

## https加密的过程？

客户端请求服务器获取证书公钥
客户端(SSL/TLS)解析证书（无效会弹出警告）
生成随机值
用公钥加密随机值生成密钥
客户端将秘钥发送给服务器
服务端用私钥解密秘钥得到随机值
将信息和随机值混合在一起进行对称加密
将加密的内容发送给客户端
客户端用秘钥解密信息

## TCP是有序的协议吗？怎么样保证？

有序，有序列号和应答号，然后超时重传

 主机每次发送数据的时候，TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配一个序列号进行确认，接受主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否存在丢失的现象。 

## nginx是干什么用的？（作为服务器去使用。）

## nginx的代理服务、缓存机制？（代理，请求转发到其他服务器；缓存，就是会缓存他代理的数据）

## nginx的负载均衡干什么用的？（减轻服务器的压力，提高性能）

## nginx的负载均衡的算法有哪些？

## mysql的索引都有哪些类型？（这里一开始可迷了，后来说了，联合索引，覆盖索引，前缀索引）

## 那什么是联合索引呢？（介绍了下，然后从B+ tree的角度说了下）

## 为什么redis的操作是原子的？

 Redis的操作之所以是原子性的，是因为Redis是单线程的。 

## 使用MySQL的时候，怎么判断要不要加索引

1. 较频繁的作为查询条件的字段应该创建索引；
2. 唯一性太差的字段不适合单独创建索引，即使该字段频繁作为查询条件；
3. 更新非常频繁的字段不适合创建索引。

## redis为什么这么快？

redis的review

## 5、epoll的源码有没有看过？

上面有

## 讲一下defer

## defer有什么特性

## 假设在一个函数体中对临界资源进行加锁和解锁，使用defer进行解锁和自己手动解锁有什么区别？

## 反射了解吗？

最关键就是interface类型中有两个结构体，一个是实现函数的`iface`和`eface`，iface中有静态类型的inter和type字段，eface中有type字段。

最狗血（因为看不懂）的地方来了，当你把一个任意类型的值转成（或者赋值）一个interface就会把类型转成对应的数字（举例而已啊，不准确110就代表int，111代表int64），然后赋值给iface中的type（类型变数字，然后赋值到type上，eface也有差不多的作用）。

别问我为什么一赋值就会把类型（转数字后）赋值给type字段，很神奇。

也就是说当你把一个int转成interface的时候，其实interface内部是保留了int的类型的（值就不用说了，肯定留着），然后反射的时候他妈的只是负责把interface里面的东西（其中就包括类型）给拿出来而已，怎么拿？？别忘了，这时候的interface你可以把它当成一个结构体，然后我反射内部定义一个跟interface差不多的结构体，然后把interface先转成unfase.Pointer（这鬼玩意至今不懂），然后强制类型转成反射内部的结构体，然后赋值给反射对象...对他妈的又是赋值，为什么赋值能搞定这么多的事情？？？？

我上面说了，反射内部的结构体跟interface大差不差，肯定也有type字段，类型就拿到了，值肯定也有。

不信？？网上在标准包外部实现了一个反射底层的赋值这块

**目前已知道在interface赋值的过程中会调用convTxx（类似于convT64）函数，这个函数会返回值对应unsafe.Pointer或者iface，至于类型估计是在编译时期就默认知道的，猜测：赋值的时候肯定知道interface对面的类型是什么**

```
type iface struct {
	tab  *itab
	data unsafe.Pointer
}
type itab struct {
	inter uintptr
	_type uintptr
	link  uintptr
	hash  uint32
	_     [4]byte
	fun   [1]uintptr
}

type eface struct {
	_type uintptr
	data  unsafe.Pointer
}

func main() {
	var i interface{}
	data := 5
	i = data // 把int先转成interface,这时候内部的interface结构体已经拿到类型了

	//接下来反射只需要定义一个跟interface很想的结构体,这里是eface,然后赋值
	//每个值都会自动的过去,神奇不神奇???
	e := (*eface)(unsafe.Pointer(&i))
	//打印出来的type是一个数字，但是这个数字是固定的，能代表int类型
	//你换一个int类型的变量，里面值随便换最终的type都是一样的
	fmt.Printf("type: %v, value: %v\n", e._type, e.data)
}
```

 [https://www.cnblogs.com/qcrao-2018/p/10822655.html#%E5%8F%8D%E5%B0%84%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84](https://www.cnblogs.com/qcrao-2018/p/10822655.html#反射是如何实现的) 

 https://i6448038.github.io/2020/02/15/golang-reflection/ 

## 怎么保证不丢包？如果一直丢包，怎么办，一直重传的话，能重传多少次？ …

## Go如何调度，假设4核的cpu应该有几个线程或者说有几个M，那能有几个groutinue，groutinue数量的上限是多少？

## 虚拟内存？操作系统怎么实现虚拟内存？

## 用户态和内核态在内存分布上是什么样的

## groutinue什么时候会被挂起

 time.sleep
socket循环读取消息
channel信道阻塞 

## redis的memcache的区别？

## B+ tree 和B Tree的区别，说下B树？

## 乐观锁和悲观锁的区别？

看数据库的review

## close_wait过多

## Redis 内存回收机制

Redis的内存回收主要分为过期删除策略和内存淘汰策略两部分。 

见redis的review

## 自旋锁和互斥锁

 斥锁：用于保护临界区，确保同一时间只有一个线程访问数据。对共享资源的访问，先对互斥量进行加锁，如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁。在完成了对共享资源的访问后，要对互斥量进行解锁。 

自旋锁：与互斥量类似，它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等(自旋)阻塞状态。用在以下情况：锁持有的时间短，而且线程并不希望在重新调度上花太多的成本。"原地打转"。 

区别点：是否占用cpu，是否阻塞。

## linux的查看进程，网络，磁盘，内存的命令

#### 进程

ps -ef # 查看所有进程
top # 实时显示进程状态 

#### 网络

netstat -lntp # 查看所有监听端口
netstat -antp # 查看所有已经建立的连接
netstat -s # 查看网络统计信息 

#### 内存

free

#### 磁盘

df：查看文件系统

du：查看目录和文件	

## 指针和引用区别

对于引用，我们要先说明一下定义一个变量的含义，这背后发生了什么？

```
对于编译器，它会搜集我们的变量名，比如我们定义了一个全局的int a;那么编译器都为我们做了什么呢？
它会为程序预留4个字节的空间（假设在32位平台），并把我们的变量名“a”保存进符号表，并用这个符号表的索引对应实际的空间。
如果下面出现b = a;那么它就会根据符号表找到变量的真正的物理位置，取得它的值，赋给b。
这是写编译器需要做的，我们需要建立符号表。
但是实际在汇编层次上，操作的都是地址而已，不存在任何名称了。 
```

所以这下看引用，我们可以知道，实际上就是定义了一个新的变量，但是跟原来那个变量指向同一个空间，所以我们说引用是内存的别名就是这样。

从表面上讲，指针是内存的地址，引用是内存的别名，从根本上来讲，两个没区别，引用是个语法糖。

## TCP如何实现可靠传输

 https://blog.csdn.net/guoweimelon/article/details/50878503 

（1）首先，采用三次握手来建立TCP连接，四次握手来释放TCP连接，从而保证建立的传输信道是可靠的。

（2）其次，TCP采用了连续ARQ协议（回退N，Go-back-N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。

（3）最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。

## Goroutines和线程区别

#### 开销

goroutine是动态栈， 一般只需要2KB。一个而goroutine的栈的最大值有1GB 。

 每一个OS线程都有一个固定大小的内存块(一般会是2MB)来做栈 。

#### Goroutine调度

一个是操作系统的调度，一个是用户态调度。

## HTTP 协议的连接过程？

#### 请求 TCP 连接

首先，浏览器与 Web 服务器的 HTTP 80端口建立一个 TCP 套接字连接。

#### 发送 HTTP 请求

通过 TCP 连接，浏览器向服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据组成。

#### 接受请求返回响应

Web服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由浏览器读取。一个响应由状态行、响应头部、空行和响应数据组成。

#### 释放TCP连接

若 connection 模式为 close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放 TCP 连接

若connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求。

#### 解析 HTML 内容

浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

## DNS 是什么？DNS 的查询过程？

DNS 是域名系统，通常用来解析域名为 IP 地址。

#### 本地解析

 通过本地缓存进行解析。

#### 直接解析 

向**客户机所设定的局部 DNS 服务器**发一个查询请求。

#### 递归解析 

局部 DNS 服务器向该域名的**根域服务器**查询，再由根域名服务器**一级级向下查询**。

#### 迭代解析 

局部 DNS 服务器把**请求转发**至上一级 DNS 服务器，再**请求上上级**直到查询到该域名。