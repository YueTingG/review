## 进程调度：

####  **先来先服务（FCFS）以及短作业优先（SJF）两种调度算法**

#### 进程调度算法

**先来先服务调度算法FCFS：**既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利；

**短作业优先调度算法SJF：**作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；

**高相应比算法HRN：**响应比=(等待时间+要求服务时间)/要求服务时间；

**时间片轮转调度RR：**按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;

**多级反馈队列调度算法：**目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。只有当前一个队列为空的时候才会去调度下一个队列的进程。

### **各种时间**：

要明确一点的是，完成时间是一个时间点，周转时间是一个时间段。

主要掌握周转时间以及，带权周转时间，剩下两个就是求平均的问题了

> 周转时间=完成时间-到达时间 
>
> 带权周转时间=周转时间/服务时间（除法运算） 
>
> 平均周转时间=周转时间/进程数（除法运算）
>
> 平均带权周转时间=带权周转时间/进程数（除法运算 

**套路：**由**到达时间**和**服务时间**先求**完成时间**，再求**周转时间**，剩下的就好求了。

## 权限

 文件夹要读的话就得包含 读和执行 权限 

## 进程

### 进程和线程是什么的最新答法

<u>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。</u>

<u>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位</u>。

## 进程基本介绍

进程是程序执行时的一个实例，**是系统进行资源分配的基本单位**。所有与该进程有关的资源，都被记录在进程控制块(PCB)中。以表示该进程拥有这些资源或正在使用它们。另外，进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，**不同的进程拥有不同的虚拟地址空间**，而同一进程内的不同线程共享同一地址空间。

**程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列**，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。

#### 记不住就这怎么答：

> 进程是**是系统进行资源分配的基本单位**，**进程拥有自己的虚拟地址空间**，**程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列**。

## 线程基本介绍

线程，有时也被称为轻量级进程，是程序执行流的最小单元，是进程中的一个实体，**是被系统独立调度和分派的基本单位**。与进程不同，线程与资源分配无关，线程自己不拥有系统资源，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。线程只由相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成。

**它是进程的一个执行流**，

#### 记不住就这怎么答：

> **线程是进程的一个执行流**，**是CPU调度和分派的基本单位**，**线程间共享进程的所有资源**。

## 进程与线程的区别

 https://www.cnblogs.com/coder-programming/p/10595804.html 

1. 地址空间：线程共享本进程的地址空间，而进程之间是独立的地址空间。

2. 调度 ：在引入线程的操作系统中，线程是调度和分配的基本单位  

3. 资源：线程共享本进程的资源如内存、I/O、cpu等，不利于资源的管理和保护，而进程之间的资源是独立的，能很好的进行资源管理和保护。

4.  通信： 线程之间的通信比较方便，统一进程下的线程共享数据（比如全局变量，静态变量），进程之间的通信比较复杂，需要以IPC进行。

5. 切换（这个最好不要答）：

6. 执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口，执行开销大。

   但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，执行开销小。

## 协程

协程是一种轻量级的用户态线程。

协程是一个可以挂起可以恢复的函数（ 协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。 ）。

## Goroutines和线程区别

#### 开销

goroutine是动态栈， 一般只需要2KB。一个而goroutine的栈的最大值有1GB 。

 每一个OS线程都有一个固定大小的内存块(一般会是2MB)来做栈 。

#### Goroutine调度

一个是操作系统的调度，一个是用户态调度。

## 进程通信

**第一类：传统的Unix通信机制**
 **1. 管道/匿名管道(pipe)**

- 管道是**半双工**的，数据**只能向一个方向流动**；需要双方通信时，需要建立起两个管道。

- 只能用于**父子进程或者兄弟进程**之间(具有亲缘关系的进程);

- 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且**只存在与内存**中。

- 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。

   ![img](https://upload-images.jianshu.io/upload_images/1281379-05378521a7b41af4.png?imageMogr2/auto-orient/strip|imageView2/2/w/228/format/webp) 

**管道的实质：**
 管道的实质是一个**内核缓冲区**，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。
 该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。
 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。

**2. 有名管道(FIFO)**
 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)。
 有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，**以有名管道的文件形式存在于文件系统中**，这样，**即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信**，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循**先进先出(first in first out)**,对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。**有名管道的名字存在于文件系统中，内容存放在内存中。**

**3. 信号(Signal)** 

**4. 消息(Message)队列**

- 消息队列是**存放在内核中的消息链表**，每个消息队列由消息队列标识符表示。
- 与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。
- 另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。

**5. 共享内存(share memory)**

- 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。
- 为了在多个进程间交换信息，**内核专门留出了一块内存区**，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。
- 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。

在Linux中，每个进程都有属于自己的进程控制块（PCB）和地址空间（Addr Space），并且都有一个与之对应的页表，负责将进程的虚拟地址与物理地址进行映射，通过内存管理单元（MMU）进行管理。两个不同的虚拟地址通过页表映射到物理空间的同一区域，它们所指向的这块区域即共享内存。

共享内存的通信原理示意图：
![20180416112848158](C:\Users\78478\Pictures\Saved Pictures\20180416112848158.jpg)

 **6. 信号量(semaphore)**
信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。 pv操作

**7. 套接字(socket)**
 套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。

## 内核态用户态

### 区别

 用户态和内核态是操作系统的两种运行级别，两者最大的区别就是**特权级不同**。用户态拥有最低的特权级，内核态拥有较高的特权级。**运行在用户态的程序不能直接访问操作系统内核数据结构和程序。** 

### 内核态

当一个任务(进程)执行系统调用而陷入内核代码中运行时，我们称之为内核态，此时程序运行在0级特权级上 。

 内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。 

### 用户态

当进程在执行自己的代码时，称其处于用户态，此时程序运行在3级特权级上。

用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。

###  用户态切换到内核态的3种方式:

（1）系统调用
（2）异常
（3）外围设备的中断 

##  I/O 过程 

各种方式不一样，但一般可概述为两个阶段： 

1. 等待数据准备好，到达内核缓冲区； 
2. 从内核向进程复制数据。 

## 5种io模型

 https://www.jianshu.com/p/6a6845464770 

 [自己看](https://zhuanlan.zhihu.com/p/73361428)

多路复用就是服务端可以注册多个io，例如文件描述符的范围，在这里范围内的，我都帮你做监听，监听期间select进程阻塞，阻塞完了，继续执行下面的代码。

[阻塞，异步](https://blog.csdn.net/historyasamirror/article/details/5778378)

### 同步阻塞 IO

什么时候知道好了：当数据被拷贝到用户进程时就知道io好了

1次io

### 同步非阻塞 IO

什么时候知道好了：进程自己不断去轮询访问，如果内核的缓冲区中有数据那么它会返回给进程，没有数据会返回一个错误代码。

估计要多次io，都是非阻塞的。

non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的，所以非阻塞io也是同步的。

### IO 多路复用

也是阻塞，只不过可以多个io。

什么时候好：当发现内核缓冲区有数据，注意此时没有拷贝到用户空间，而是得用户进程自己去系统调用读取，select只是发现缓冲区有数据而已。

select进行系统调用，返回代表内核缓冲区有数据了，然后再次调用读的系统调用去真正读取数据。

所以2次io

**IO 多路复用是什么意思？**

在同一个线程里面， 通过拨开关的方式，来同时传输多个I/O流， (学过EE的人现在可以站出来义正严辞说这个叫“时分复用”了）。

什么，你还没有搞懂“一个请求到来了，nginx使用epoll接收请求的过程是怎样的”， 多看看这个图就了解了。提醒下，ngnix会有很多链接进来， epoll会把他们都监视起来，然后像拨开关一样，谁有数据就拨向谁，然后调用相应的代码处理。

![img](https://images2015.cnblogs.com/blog/43136/201703/43136-20170319171538682-1895749865.jpg)

 要弄清问题 先要知道问题的出现原因
原因:
由于进程的执行过程是线性的(也就是顺序执行),当我们调用低速系统I/O(read,write,accept等等),进程可能阻塞,此时进程就阻塞在这个调用上,不能执行其他操作.阻塞很正常. 接下来考虑这么一个问题:一个服务器进程和一个客户端进程通信,服务器端read(sockfd1,bud,bufsize),此时客户端进程没有发送数据,那么read(阻塞调用)将阻塞直到客户端调用write(sockfd,but,size)发来数据. **在一个客户和服务器通信时这没什么问题,当多个客户与服务器通信时,若服务器阻塞于其中一个客户sockfd1,当另一个客户的数据到达套接字sockfd2时,服务器不能处理,仍然阻塞在read(sockfd1,...)上;此时问题就出现了,不能及时处理另一个客户的服务,咋么办?  I/O多路复用来解决**!
I/O多路复用：
继续上面的问题,有多个客户连接,sockfd1,sockfd2,sockfd3..sockfdn同时监听这n个客户,当其中有一个发来消息时就从select的阻塞中返回,然后就调用read读取收到消息的sockfd,然后又循环回select阻塞;这样就不会因为阻塞在其中一个上而不能处理另一个客户的消息 

### 信号驱动式IO

 首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据 

### 异步非阻塞 IO

整个过程都是非阻塞的，不管是最开始发起系统调用，还是最后读取io数据都是非阻塞的。因为数据的拷贝也是内核做的，做完了它再给进程一个信号。

所以，它两次io都是非阻塞的，进程一直都在做自己的事情。

## 线程同步的方式有哪些？

#### 互斥量

互斥量是一个可以处于两态之一的变量：解锁和加锁。常常用一个整型量表示，0表示解锁，而其他所有值表示加锁。

进入临界区之后**禁用中断**，采用的方法就是 `TSL`（测试并上锁）

可以使用 TSL（测试并上锁） 或者XCHG指令来实现（XCHG指令）：

![](C:\Users\78478\Desktop\review\Snipaste_2020-07-13_15-15-49.png)

#### 信号量

一个非负整数。

P（SV）：如果SV的值大于0，就将它减1；如果SV的值为0，则挂起进程的执行。

V（SV）：加1，如果信号量上有休眠的进程，则唤醒它。

```
	规定S1和S2的初值分别为1和0

      	生产者                           消费者
    	P(S1)                      		P(S2) ;
        启动读卡机                     从缓冲区取出信息 
          …                           
        收到输入结束中断                   V(S1);
        V(S2);                         加工并且存盘
        goto L1;                       goto L2;

```

对 pv 的另外一种解释

```
P(S):顺序执行下述两个动作：
　　①信号量的值减1，即S=S-1；
　　②如果S≥0，则该进程继续执行；
　　　如果S＜0，则把该进程的状态置为阻塞态，把相应的PCB连入该信号量队列的末尾，并放弃处理机，进行等待（直至其它进程在S上执行V操作，把它释放出来为止）。
　　　
V(S):顺序执行下述两个动作：
　　①S值加1，即S=S+1；
　　②如果S＞0，则该进程继续运行；
　　如果S≤0，则释放信号量队列上的第一个PCB（即信号量指针项所指向的PCB）所对应的进程（把阻塞态改为就绪态），执行V操作的进程继续运行。
```

#### 条件变量（条件锁）

包含了进程通信机制，当条件变量达到某个值，会主动唤醒因为这个变量堵塞的所有线程。

## 互斥量和信号量的区别

从根本来讲，是这两者使用的场景不同，导致了这两者诞生所面对和应付的场景不同。

 https://www.zhihu.com/question/47704079 看**二律背反**的回答

#### 互斥量

互斥量所应对的场景是需要保护临界区，保护共享代码段而诞生的。举例，我现在有一段代码，我希望某一刻只有一个线程访问，这时候需要加锁，这就是互斥量。

#### 信号量

信号量的应用场景是什么？控制线程的顺序执行，跟保护某一段代码无关？什么意思？我现在有两个线程，一个是生产者，一个是消费者，但是这俩都是多线程，但是从逻辑上来讲，一定要有人生产我才能消费，也就是生产者先执行，然后才是消费者。

这时候我就需要信号量出来了，消费者要P，生产者要V。

## 锁的实现

 https://blog.csdn.net/qq_35181209/article/details/78026636 这个鬼东西实际上是依赖硬件实现的

 test and set 

单核：保证指令是原子操作

多核：锁内存总线，保证从多核上来讲也是原子的

## 死锁

死锁产生的四个条件（有一个条件不成立，则不会产生死锁）

互斥；不可剥夺；请求和保持；循环等待；

- 互斥条件：一个资源一次只能被一个进程使用
- 占有并等待：一个进程因请求资源而阻塞时，对已获得资源保持不放
- 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺
- 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系

**死锁的预防**：打破上面4种条件

可以把资源一次性分配：（破坏请求和保持条件）

然后剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）

资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

**死锁的避免**：银行家算法

## 分页和分段有什么区别？

- 段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。
- 段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定
- 段向用户提供二维地址空间；页向用户提供的是一维地址空间
- 段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。

## 页面置换算法

**最佳置换算法：**只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。

**先进先出置换算法：**简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。

**最近最久未使用算法LRU：**算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。

**时钟算法clock(也被称为是最近未使用算法NRU)：**页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。

**改进型Clock算法：**在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。

**最少使用算法LFU：**设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。

##  **什么是缓冲区溢出** 

 缓冲区溢出是指当计算机向缓冲区内填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。 

## 进程空间分几段 

  1.Text：存放可执行的指令操作，其只读不能写。 

  2.Bss：存放未初始化的全局变量和静态变量。 

  3.Data：存放初始化的全局变量和静态变量。 

  4.Stack：存放临时变量，函数参数等。 

  5.Heap：存放New/Malloc等动态申请的变量，用户必须手动进行Delete/Free操作。 

  其中Stack和Heap的内存增长方向是相反的。

## 以下多线程对int型变量x的操作,哪个不需要进行同步()

- ```
  ++x
  ```

- ```
  x=y
  ```

- ```
  x++
  ```

- ```
  x=1
  ```

```
前三个都至少需要先读取，再操作，非原子操作。而D的话，直接赋值。

做过一些微架构的东西，大家说的都挺好，我从指令集方面说说。
D项通过编译后，应该是：mov 1,eax。x对应寄存器eax，所以是原子操作；
而其他几项，都需要先读取x即load eax,x（比如将x读入eax寄存器中），然后在修改；但是多线程下，其他线程也可以读x啊，所以就存在同步问题了。
对了，同步就是将读取x内存区的地址总线申请独享！
```

主要要理解一下，原子性并不一定就是要底层还有指令相关，单纯的代码也可以有原子性。

可以看一下链接 https://www.nowcoder.com/questionTerminal/ca8eeb490bac45cbaa89e9ec77766f78 

## 操作系统--多线程之间共享哪些资源？

结合进程空间的分布更容易弄懂这题。

 https://blog.csdn.net/sinat_21026543/article/details/81912378 

## IO模式和IO多路复用

 https://www.cnblogs.com/zingp/p/6863170.html 

##  关于虚拟内存技术 

#### 什么是虚拟内存

1. 请求分页系统、请求分段系统和请求段页式系统都是建立在虚拟内存技术上的。
2. 进程运行过程动态分配内存时，只是分配了虚拟内存，即为对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。
3. 维基百科的概念： **虚拟内存** 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。 

#### 作用

1. 扩充地址空间；
2. 内存保护；（虚拟内存技术提供了写保护机制）
3. 可以节省内存；(如多个程序都用到一个库时，这个库在物理内存上只存在一份即可)
4. 充分利用物理内存（提高利用率）；（分配内存时只需要在虚拟内存空间连续，物理内存无需连续）
5. 可用于进程通信；（虚拟内存共享方式）

#### 【缺点】

1.需要占用额外内存；(如页表)
2.消耗更多CPU资源；(地砖转换)
3.跟耗时;(页面置换需要磁盘I/O)

##  关于缺页中断 

缺页中断是一种特殊的中断类型，在程序运行期间访问的页面不存在于内存时产生。

#### 【大致过程】

1.保护CPU现场；
2.分析中断原因;
3.转入缺页中断处理程序进行处理 ；
4.恢复CPU现场，继续执行；

#### 【笔记】

又硬件产生；
指令执行期间产生；
一条指令在执行期间可能产生多次缺页中断

#  关于页表寻址 

```
【概述】
页表记录虚拟地址到物理地址的映射，操作系统为每个进程维护一个页表。
【细节】
一个虚拟地址中包含了页表号和页内偏移量信息，转换时通过高位的页表号查页表得到对应物理页面号（页基地址），再根据偏移量得出最终的物理地址。
【备注】
~ 通常整个寻址过程可以又硬件完成，因此效率高。
~ 页表一般是常驻内存的。
~ 多级页表的有点是页表可以离散存储，从而节省主存空间。
```

 关于页面置换 

```
【笔记】
~ 发生时机：访问内存中不存在的页，但是可用内存已满。
~ 操作：将内存中一些页面调到磁盘的对换区腾出空间再调入所需的页面。(交换技术)
~ 常见算法：FIFO,LRU(最常用),
```

 程序的内存结构 

 ![img](https://uploader.shimo.im/f/H7pLBohD3ux72Hvu.PNG!thumbnail) 

```
【简单解析】
~ BSS段：未初始化数据区，静态分配，存放如未初始化的全局变量。
~ 数据段：静态分配，存放如已初始化的全局变量；
~ 代码段：大小固定，只读，存放执行的代码（指令）
~ 栈区：存放如函数的参数、局部变量等数据，向下增长，自动释放，最大容量是固定的。
~ 堆区：用于动态分配内存，采用链式存储结构，申请时需要执行一定的搜索算法，效率比栈低；
```

## 常见寄存器的作用

```
SP 栈指针，指向当前栈的栈顶地址
PC 程序计数器，存储下一条指令
IR  指令寄存器，暂存当前正在执行的指令
EAX 累加寄存器，用于加法乘法的缺省寄存器     
IP 指令指针，放下次将要执行的指令在代码段的偏移量
```

