## 699个结点的完全二叉树，有叶子节点多少个?

- ```
  350
  ```

- ```
  699
  ```

- ```
  1398
  ```

- ```
  以上都不正确
  ```

#### 一

 链接：https://www.nowcoder.com/questionTerminal/34b594edb53b4424923ca09c7bd233e9
来源：牛客网

首先你得知道什么叫完全二叉树! 
 完全二叉树(Complete Binary Tree) 
 若设二叉树的高度为h,除第 h 层外,其它各层 (1～h-1)  的结点数都达到最大个数,第 h 层所有的节点都连续集中在最左边,这就是完全二叉树. 完全二叉树是由满二叉树而引出来的.对于深度为K的,有N个结点的二叉树,当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树. 
 做这种题目你要知道二叉树的两个特点!第k层的节点个数最多2^(k-1)个,高度为k层的二叉树,最多2^k-1个节点! 
 则在本题目敏感词699个节点,因为是完全二叉树,2^10-1>699>2^9-1,所以高度为10,可以确定1到9层全满,节点总算为511,剩下的188个肯定为叶子节点!第10层上的188个节点挂在第九层的188/2=94个节点上,则第九层剩下的2^（9-1）-94=162个也为叶子节点,最后总共**188+162=350**个叶子节点! 

#### 二

有个简单的记住办法，要是节点数为偶数则直接除以2即可，要是为奇数则节点数加1后除以2 

## **在Linux中，进程的内存空间按低地址到高地址的顺序分为：**

代码段text、数据段data、bss段、堆、栈和内核数据区（命令行参数和环境变量等）。 

## 若数据链路的发送窗口尺寸WT=4，在发送3号帧、并接到2号帧的确认帧后，发送方还可连续发送（ ）。

- ```
  2帧
  ```

- ```
  3帧
  ```

- ```
  4帧
  ```

- ```
  1帧
  ```

**窗口就是总共能发多少**，里面既有还能发送的，也有已经发送但还没ack的。

## 二叉树计算

https://www.cnblogs.com/wangzheming35/p/13278348.html

#### 一颗二叉树具有41个结点，叶子有19个，度数为1的有多少个

*设，n0代表度数为0也就是叶子结点的个数，n1代表度数为一的个数，n2代表度数为2的个数，**所谓度数，看的是有多少个孩子**，例如叶子结点有父亲，但是没有孩子，所以没有度数（其实是图才有的概念，就是有父亲连接）*

这道题其实核心就两个公式，n0 = n2+1（这道公式只能死记硬背，关键时刻如果记不住，可以写颗二叉树验证一下，哪边加一）

n = n0+n1+n2，这道公式是可以理解的，二叉树一共就三种结点，度数为0的（叶子），度数为1的和度数为2的。

核心：

n0 = n2+1，n = n0+n1+n2，把已知带入，叶子有19个，说明 n0=19，所以推出 n2=18，n0知道，n2知道，又知道n，自然求出n1。

####  设一棵二叉树中有3个叶子节点，有8个度为1的节点，则该二叉树中总的节点数为？ 

同样是根据 n0=n2+1，和 n=n0+n1+n2，可以求出。

## 某网络的IP地址空间为192.168.5.0/24，采用定长子网划分，子网掩码为255.255.255.248，则该网络的最大子网个数，每个子网内的最大可分配地址个数为各为多少？ 

链接：https://www.nowcoder.com/questionTerminal/5ad9d4b7c6024571a36a6cadddcf0a2f?toCommentId=50910来源：牛客网

- ```
  32. 6
  ```

- ```
  32. 8
  ```

- ```
  8. 32
  ```

- ```
  8. 30
  ```

**解析：**

首先前面前 24 位就是不用管，我们只需要管剩下的 8 位。而子网掩码最后 248 可以得出 `1111   1000` 即前 5 位代表子网的个数，后 3 个代表每个子网内可分配的最大主机个数

## 数据链路层采用了后退N帧（GBN）协议，发送方已经发送了编号为0~7的帧。当计数器超时时，若发送方只收到0、2、3号帧的确认，则发送方需要发的帧数是（）。

- ```
  2
  ```

- ```
  3
  ```

- ```
  4
  ```

- ```
  5
  ```

**解析：**

后退 N 帧是这样，如果我收到 3 号帧，代表前面 0~3 都是收到确认了，剩下的 4，5，6，7 需要确认。

## 运算符优先级要复习

## 红黑树中已经有n个数据，寻找某个key是否存在的时间复杂度为()。

- ```
  o(logn)
  ```

- ```
  o(n)
  ```

- ```
  o(n二次方)
  ```

- ```
  o(1)
  ```

**解析：**

这道题你要明白一个道理就可以了，就是红黑树是一种二叉搜索树，二叉搜索树查找的特点就是二分法。

所以是 O(log n)

## golang 比较

切片不能比较

```
	arr1 := []int{1, 2, 3}
	arr2 := []int{3, 4}
	
	if arr1 == arr2 {

	}
	// 报错
```

map 不能比较

```
m1 := map[int]int{}
	m2 := map[int]int{}

	if m1 == m2 {
		
	}
	// 报错
```

func 不能比较

```
	f1 := func(a,b int){}
	f2 := func(a,b int){}

	if f1 == f2 {

	}
```

chan **可以**比较

```
ch1 := make(chan int)
	ch2 := make(chan int)

	if ch1 == ch2 {
		fmt.Println("t")
	} else {
		fmt.Println("n")
	}
```

## golang map key 的问题

http://lanlingzi.cn/post/technical/2016/0904_go_map/

上面提到的 slice map func 都不能比较，所以也都不能当 key。

struct 是可以比较的，地址也是可以比较的，当然两个相同类型的对象的值可以相等，但是地址往往不等（等了还得了）

所以 struct 是可以作为 key 的。

**chan 也是可以作为 key**。

## golang 引用类型

 **引用类型有**：slice切片、管道channel、map、函数（前 4 个）、指针、接口interface

## ceil 向上取整

```
ceil(3.14) // 4
```

## slice，map，func，chan

这 4 个都是**引用类型**，前 3 个都**不可以比较**，**只有 chan 可以比较**。

## 下列（）进程调度算法会引起进程的饥饿问题。 

短作业优先，和优先级 都会饥饿。

## 由权值为9,2,7,5的四个叶子节点构造一棵哈夫曼树，该树的带权路径长度为：

- ```
  23
  ```

- ```
  37
  ```

- ```
  44
  ```

- ```
  27
  ```

**解析：**

第一层要除外，第一层不是1。

![](C:\Users\78478\Desktop\review\706564_1426154322428_20150312175819.png)