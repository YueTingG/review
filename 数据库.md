## 关系代数

### 选择运算（select）==>相当于SQL语句中的WHERE子句的职能

- #### **格式：σ选择谓词(关系)**

- 举个栗子： 

  - σSAL>1000(EMP)
  - 上式表示取出查询工资大于1000的所有员工的信息
  - 等价于下面的SQL语句

  ```sql
  SELECT *
  FROM EMP
  WHERE SAL > 1000
  ```

> **关系模式R（a，b，c，d）中关系代数表达式σ3<‘4’** 中的3代表第三列，整句话的意思是：
>
>  **从R中选择第三列的属性值小于4的行** 

### 投影运算（project）==>相当于SQL语句中的SELECT子句的职能

- #### 格式：∏字段序列(关系)

- 举个栗子 

  - ∏ENAME,SAL(EMP)
  - 上式表示查看所有员工的姓名和工资
  - 等价于下面的SQL语句

  ```sql
  SELECT ENAME, SAL
  FROM EMP
  ```

#### `特别注意`

##### **由于投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组，因为取消了某些属性列之后，就可能出现重复行，`投影结果中不应该包含重复行`**

 例子：查询学生关系Student中都有哪些系，即查询关系Student上所在系属性上的投影
Student关系如图所示： 

| `Sname` | `Sdept` |
| :-----: | :-----: |
|  李勇   |   CS    |
|  刘晨   |   CS    |
| 王小明  |   MA    |
|  张超   |   IS    |

求 ： `π Sdept(Student)`

##### 因为Student关系原来有4个元组，但是我们的投影结果需要取消重复的CS元组，因此投影结果只有三个元组：

| `Sdept` |
| :-----: |
|   CS    |
|   MA    |
|   IS    |

### 关系的组合运算==>就像SQL中select、where子句那样的组合效果

- 举个栗子 

  - ∏ENAME,SAL(σSAL>1000(EMP))
  - 上面的式子求出了所有工资大于1000的员工的名字和工资(实际上就是将**σSAL>1000(EMP)**执行的结果当做一个临时的关系，参与了投影运算得到的)
  - 等价于下面的SQL语句

  ```sql
  SELECT ENAME, SAL
  FROM EMP
  WHERE SAL > 1000
  ```

- 事实关系的组合运算就是那么简单，分析的时候把每个简单运算的结果当做一个新的关系参与后面的运算，这样一层层剥开来，再复杂的语句也变得容易分析

## 数据库范式

 https://www.zhihu.com/question/24696366 ,里面讲得很清楚

### 第一范式

**符合1NF的关系中的每个属性都不可再分。表1**所示的情况，就不符合1NF的要求。 

### 第二范式

 ![img](https://pic4.zhimg.com/80/5b16f655b57a957bfa340d0a996a0eea_1440w.jpg) 

#### 函数依赖

**若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y**。 

理解上类似于 `f(x)=y`，根据x可以确定y。

一般我们说**某个非主属性函数依赖于码**（或者主属性），理解上可以这么说，**根据码可以唯一确定某个非主属性**。

举例，学号可以确定姓名，姓名函数依赖于学号（注意，这里学号并不是码，而是一个主属性，这里的码是学号以及课名）。

#### 部分函数依赖:

我们说过，这里的码是学号+课名，而姓名函数依赖于学号，所以**姓名对于码是部分函数依赖**（具体看连接里面，里面更加详细）

#### 什么是第二范式

那么到这里，我们可以尝试给第二范式下定义（不准确的定义，通俗的讲），就是**消除非主属性对于码的部分函数依赖**。像`（学号，课名） F→ 分数` 就是一个典型的部分函数依赖。所以上面表步满足第二范式。

#### 如何判断是否满足第二范式

当然这是我们提前告知，所以我才知道存在部分函数依赖的，现在的要求是，如何从头判断一张表是否满足第二范式。

步骤：

第一步：找出数据表中所有的**码**。
第二步：根据第一步所得到的码，找出所有的**主属性**。
第三步：数据表中，除去所有的主属性，剩下的就都是**非主属性**了。
第四步：查看是否存在非主属性对码的**部分函数依赖**。 

 第一步： 

1. 查看所有每一单个属性，当它的值确定了，是否剩下的所有属性值都能确定。
2. 查看所有包含有两个属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。
3. ……
4. 查看所有包含了六个属性，也就是所有属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。

看起来很麻烦是吧，但是这里有一个诀窍，就是假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是码了（因为作为码的要求里有一个“**完全**函数依赖”）。

例如，尝试学号，发现学号无法唯一确定分数（其他单个属性也尝试一遍，然后发现都不行），尝试属性组合，学号+姓名发现无法唯一确定分数（然后其他属性组合也试一遍）最后发现，学号+课名可以唯一确定剩下所有属性，所以学号+课名是码

 ![img](https://pic3.zhimg.com/80/51e2689ac9416a91800e63101bee9db7_1440w.jpg) 

第二步：
主属性有两个：**学号** 与 **课名**

第三步：
非主属性有四个：**姓名**、**系名**、**系主任**、**分数**

**第四步：**
对于**（学号，课名） → 姓名**，有 **学号 → 姓名**，存在非主属性 **姓名** 对码**（学号，课名）**的部分函数依赖。
对于**（学号，课名） → 系名**，有 **学号 → 系名**，存在非主属性 系**名** 对码**（学号，课名）**的部分函数依赖。
对于**（学号，课名） → 系主任**，有 **学号 → 系主任**，存在非主属性  对码**（学号，课名）**的部分函数依赖。

### 第三范式

 ![img](https://pic4.zhimg.com/80/44af74509a4e21372ed372be8560539d_1440w.jpg) 

 ![img](https://pic4.zhimg.com/80/2f4b4a887f6a61674a49d03d79e3fe17_1440w.jpg) 

#### 传递函数依赖

假如 Z 函数依赖于 Y，且 Y 函数依赖于 X ，Y 不包含于 X，且 X 不函数依赖于 Y，这个前提下，那么我们就称 Z 传递函数依赖于 X ，记作 X T→ Z，如**图3**



![img](https://pic2.zhimg.com/50/51f8105fbbe92adaa3e343ea2db3bf49_hd.jpg)

**选课表**中，系名函数依赖于学号，系主任函数依赖于系名，可以间接推导出，系主任函数依赖于学号，这就是传递依赖

#### 什么是第三范式

通俗点讲就是，消除**非主属性对码的传递依赖**

## 左连接，右连接，内连接

 https://blog.csdn.net/plg17/article/details/78758593 

## mysql数据库引擎

### MyISAM

如果表主要是用于插入新记录和读出记录，那么选择`MyISAM`引擎能实现处理高效率.只支持表锁。

##  **两种存储引擎的大致区别表现在** 

#### 最重要：两种类型最主要的差别就是Innodb 支持 `事务` 处理与 `外键` 和 `行级锁`

- **InnoDB支持事务，MyISAM不支持**，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。
- **MyISAM适合查询以及插入为主的应用**。
- **InnoDB适合频繁修改以及涉及到安全性较高的应用**。
- InnoDB支持外键，MyISAM不支持。
- **从MySQL5.5.5以后，InnoDB是默认引擎**。
- InnoDB不支持FULLTEXT（全文索引）类型的索引。
- **InnoDB中不保存表的行数**，如`select count(*) from table`时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含where条件时MyISAM也需要扫描整个表。
- 对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。
- `DELETE FROM table`时，**InnoDB不会重新建立表，而是一行一行的 删除，效率非常慢**。**MyISAM则会重建表**。
- InnoDB支持行锁（某些情况下还是锁整表，如 `update table set a=1 where user like '%lee%'`。

## 数据库索引

### 有哪些索引

索引在使用的时候要遵守最左原则，这里的**复合索引**最左字段为name，在创建 `idx_com1` (`name`,`age`,`address`)索引的时候，实际上是创建了(name)，（name，age），（name,age,address）三种索引 。

## sql

 DELETE和TRUNCATE TABLE都是删除表中的数据的语句，它们的不同之处描述正确的是： 

 delete和truncate table的最大区别是delete可以通过WHERE语句选择要删除的记录。但执行得速度不快。而且还可以返回被删除的记录数。而truncate table无法删除指定的记录，而且不能返回被删除的记录。但它执行得非常快。 

1、TRUNCATE TABLE比DELETE的速度快；
2、TRUNCATE TABLE 是删除表的所有行，而DELETE是删除表的一行或者多行（除非DELETE不带WHERE语句）；
3、在删除时如果遇到任何一行违反约束（主要是外键约束），TRUNCATE TABLE仍然删除，只是表的结构及其列、约束、索引等保持不变，但DELETE是直接返回错误；
4、对于被外键约束的表，不能使用TRUNCATE TABLE，而应该使用不带WHERE语句的DELETE语句。

5、如果想保留标识计数值，要用DELETE，因为TRUNCATE TABLE会对新行标志符列搜用的计数值重置为该列的种子。

## 事务

 [https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3).md#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1](https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/事务隔离级别(图文详解).md#什么是事务) 

### 并发事务带来的问题

 **脏读（Dirty read）** ：只读一次，读取的是没提交的数据

 **不可重复读** ： **一个事务两次读取同一个数据，两次读取的数据不一致** ，读取两次，第一次读取的时候事务的**修改**还没提交，第二次读取的时候事务提交了。

 **幻读** ： **一个事务两次读取一个范围的记录，两次读取的记录数不一致** ，读取两次，第一次读取的时候事务的**添加或者删除**还没提交，第二次读取的时候事务提交了。

**丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。 

### 事务隔离级别

 **READ-UNCOMMITTED(读取未提交)：** 

 **EAD-COMMITTED(读取已提交)：** 假如现在有一个事务正在修改数据，另外一个事务不能读取，要等它完成。前提是有事务正在修改（如果我第一次读的时候，没有事务，但是中间出现了事务修改了数据，结果我第二次读的时候发现卧槽，数据不一样了，这就是不可重复读）

 **REPEATABLE-READ(可重复读)：** 为了解决上面那个问题，很简单，老子读的时候，你不准在中间修改。 就是在开始读取数据（事务开启）时，不再允许修改操作 （但是能插能删...）

 **SERIALIZABLE(可串行化)：**  最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。 

### 事务隔离的实现

mvcc和读写锁，乐观锁，悲观锁

 https://www.cnblogs.com/cjsblog/p/8365921.html 

解释： https://juejin.im/post/5b55b842f265da0f9e589e79?tdsourcetag=s_pctim_aiomsg#heading-1 

例子：  https://blog.csdn.net/whoamiyang/article/details/51901888 

 https://juejin.im/post/5cb3f55de51d456e6c732cb5#heading-18 

- SELECT
  - 读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。
- INSERT
  - 将当前事务的版本号保存至行的创建版本号
- UPDATE
  - 新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号
- DELETE
  - 将当前事务的版本号保存至行的删除版本号

快照读：读取的是快照版本，也就是历史版本

当前读：读取的是最新版本

普通的SELECT就是快照读，而UPDATE、DELETE、INSERT、SELECT ...  LOCK IN SHARE MODE、SELECT ... FOR UPDATE是当前读。 

**mvcc实现了读提交和可重复读，但是没有解决幻读**

举例，现在有事务2和3，本来数据库表里面就有数据是事务1创建的。

事务2对先查指定范围查出了1~5条数据（step1），然后依次修改这5条数据的值（step2），然后再查一次看看有没有修改（step3）。

但是，在事务2第一次查完，还没修改前，事务3在1~5中插入了一条数据，现在变成了1~6，结果因为事务2的修改是当前读，也就是会修改最新版本的数据，所以会改到事务3插入的这条数据，同时会把它的版本变成事务2，此时事务2的第二次查询（step3）查看数据是能够查到刚才事务3插进去的那条数据，可以从道理上讲，它不应该能看见。

所以，mvcc之所以不能解决幻读，关键是查只能查之前的版本（快照读），但是修改插入删除却能读到最新的版本（当前读）。

所以实际上单纯快照读使用mvcc之后是不会出现幻读的，之所以出现幻读都是因为有当前读。

**所以mvcc实际上解决了不可重复读以及快照读的幻读，配合上间隙锁才能解决当前读的幻读**

## mysql高可用方案

 https://www.cnblogs.com/wpgraceii/p/10528183.html 

## 预读

 https://www.cnblogs.com/geaozhang/p/7397699.html 

## 缓冲池

 https://juejin.im/post/5d11a79ee51d4555e372a624#heading-10 

LRU算法的优化，老生代新生代，以及滞留时间窗口

## 随机io，顺序io，回表

 https://blog.csdn.net/qq_37781649/article/details/104143590 

## 插入缓冲

 https://www.cnblogs.com/wade-luffy/p/6279500.html 

上面的链接有些需要强调：不是每一次直接插入索引页中，而是先判断插入的非聚集索引页是否在缓冲池中。如果在，则直接插入；如果不在，则先放入一个插入缓冲区中（注意是放入插入缓冲区中，不是缓冲池，插入缓冲区也是一个b+树）。

另外，为什么需要辅助索引不是唯一索引？

因为唯一索引插入前要查找索引页来判断插入数据的唯一性，但是假如你去查了，我搞插入缓冲的目的就没了，插入缓冲什么目的？就是为了避开随机io，但是你现在一查肯定回表了（不太清楚是不是一定是随机io，这里目前理解上不确定）。

上面的链接加上这个一起食用会更好： https://segmentfault.com/a/1190000022568853 

## 重做日志

 https://www.jianshu.com/p/4bcfffb27ed5 

write pos表示日志当前记录的位置，当ib_logfile_4写满后，会从ib_logfile_1从头开始记录；check point表示将日志记录的修改写进磁盘，完成数据落盘，数据落盘后checkpoint会将日志上的相关记录擦除掉，即write pos->checkpoint之间的部分是redo log空着的部分，用于记录新的记录，checkpoint->write pos之间是redo log待落盘的数据修改记录。

将redolog记为commit之后才落盘，因为是先记录要改哪些，而不是直接改，所以用checkpoint->write pos来记录要改哪些。

**好处：**

 有了redo log，当数据库发生宕机重启后，可通过redo log将未落盘的数据恢复，即保证已经提交的事务记录不会丢失。 

## 二次写(和重做日志的不同)

## 一条sql执行过程发生了什么

 https://learnku.com/articles/25879 

 https://blog.csdn.net/qq_35190492/article/details/104203466 

## MySQL主从复制

MySQL是在主库上记录二进制日志，在从库重放日志，主要设计了以下三个线程分别是`BinLog`、`I/O线程`、`SQL执行线程`。

- `BinLog`线程负责将主库上的**数据更改**记录到二进制日志中。
- `I/O`线程负责把主库的二进制日志复制放到自己的中继日志 `relay log`日志中。
- `SQL`线程则负责把中继日志（`relay log`）的更改应用到自己的数据库上。

复制的时候MySQL**默认使用基本语句**的复制，优点就是简单，缺点也明显，如果SQL依赖其它的信息，则可能会出错，当无法正确复制的时候，会动态切换到基于行的复制。

但是基于行的复制开销比较大。

## 如何实现 MySQL 的读写分离？

其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。

## 主从复制同步延迟/mysql 的强一致性

1.  **异步复制**：主把事务写到binlog日志并不管从是否接收或者什么时候接收，commit之后，不会与从发生ack之类的交互。
2.  **同步复制**：当主提交一个事务，在主向前端返回一个commit成功的指令前，必须保证所有的从已经提交了这个事务（所有从不但接收了，还必须apply了该事务日志）
3.  **半同步复制**：（5.7.2版本之前默认且唯一的一个参数值after_commit）：主上客户端发出提交指令，事务提交到了存储引擎后，等待从传递过来ack（只要有一个传过来就算成功），再向前端返回成功的状态。
   与无损复制的区别就是：如果在主上这个事务已经提交到了存储引擎，而正在等待从的ack过程中---这个时候发生creash，则主上这个事务其实已经认为commit了，而从还没commit，
   在切换到从后，就会回滚最后的这个事务，这个时候主从的时候其实就不一致了）
4.  **无损复制**：（5.7.2版本之后一个参数值after_sync）：主上客户端发出提交指令，事务写入到了binlog，传递到了从（事务写入到了relay.log且flush to disk中持久化到了磁盘的relay.log中）
   然后从给主反馈一个ack，master才会把事务提交到存储引擎且返回到client一个commit成功的指令。

#### 无损复制和半同步复制

其实在 mysql 官网并没有看到什么无损复制，其实所谓的无损复制就是半同步复制的 `rpl_semi_sync_master_wait_point` 参数设置成  `AFTER_SYNC` ，之前是 ` AFTER_COMMIT `，所以无损复制就是半同步复制的一个参数变了。