## 快速排序

1. 取任意一个元素作为基准（pivot），一般是数组开头第一个元素。
2. 从右边往左找，找到第一个小于基准的数，把它赋值给左边的数（如果是第一次的话，这个时候是基准的位置）
3. 从左往右找，找到第一个大于基准的数，把赋值给刚才右边的数。
4. 通过上面两轮我们可以发现，右边大于基准的数跑到了左边，左边大于基准的数跑到了右边。
5. 然后不断重复2和3，知道i==j。
6. 此时把基准的值赋值给arr[i]。通过一轮下来，我们可以发现，快排一次，会把小于基准的数放到基准的左边，大于基准的数放右边。
7. 此时，并没有排序好，只是大致分两类，一类是大于基准的数，一类是小于基准的数。
8. 递归调用。

```go
func quickSort(arr []int, left, right int) {
	/*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/
	if left >= right {
		return
	}
	i := left
	j := right
	pivot := arr[left]

	for i < j { /*控制在当组内寻找一遍*/
		for i < j && pivot <= arr[j] {
			/*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升
			  序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/
			j-- /*向前寻找*/
		}

		arr[i] = arr[j]
		/*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是
		  a[left]，那么就是给key）*/

		for i < j && pivot >= arr[i] {
			/*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反，
			  因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/
			i++
		}

		arr[j] = arr[i]
	}

	arr[i] = pivot             /*当在当组内找完一遍以后就把中间数key回归*/
	quickSort(arr, left, i-1)  /*最后用同样的方式对分出来的左边的小组进行同上的做法*/
	quickSort(arr, i+1, right) /*用同样的方式对分出来的右边的小组进行同上的做法*/
	/*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/
}
```

## 堆排序

1. 构建最大堆，采用向下调整法，记住向下调整下有个边界
2. 构建完毕后，然头和尾巴互换，现在尾巴就是最大的了，然后调整
3. 重复2

```
func HeapSort(nums []int) {
	start := len(nums)/2 - 1
	// 先构建成大顶堆
	for i := start; i >= 0; i-- {
		down(nums, i, len(nums))
	}
	for i := len(nums) - 1; i >= 0; i-- {
		// 第一次的时候上面构建完毕, 把头和尾巴互换
		// 现在尾巴就是最大的了
		nums[0], nums[i] = nums[i], nums[0]
		// 换完后需要调整,但是注意尾巴不属于调整的范围
		down(nums, 0, i)
	}
}

// i是调整第几个,j是调整的界限,从j往后的不需要调整
func down(nums []int, i, j int) {
	left := 2*i + 1
	right := 2*i + 2
	mid := i

	// 从left,mid和right中找出最小的那一个,然后赋值给mid
	if left < j && nums[left] > nums[mid] {
		mid = left
	}
	if right < j && nums[right] > nums[mid] {
		mid = right
	}
	if mid != i {
		nums[i], nums[mid] = nums[mid], nums[i]
		down(nums, mid, j) // 记住还需要继续往下调整,但是仍然要注意j
	}
}
```

## 插入排序

我们来观察一个数组[1,3,4,5,2]，从这个数组可以看出来实际上我们只需要移动2到指定的位置就可以了。

从动画的角度来讲，就是把“3~5往后移动一个位置”，然后2插入到1和3之间。所以实际上我们知道，“3~5往后移动一个位置”这个实际上是最难的。

```
[1,3,4,5,2] ====> [1,    ,3,4,5,2]
					   ^		|
					   |  		|
					   |--------|
```

所以“3~5往后移动一个位置”对应的就是代码中的`arr[preIndex+1] = arr[preIndex]`这句话，我们现在假设5的索引是preIndex，所以我们要把5往后移动一个位，那自然是移动到`preIndex+1`也就是2上面。

移动完为什么要--呢？我们的移动是从后面往前面进行的，可以这么说，“3~5往后移动一个位置”我们是把5往后移动，然后移动4，再移动3，一步步往前面移动，所以preIndex--。

最后为什么是`arr[preIndex+1] = current`，最后这个我们一看代码就知道是把2插入到3~5腾出来的空之中。但是为什么是preIndex+1呢？

前面的for循环结束说明什么？注意for 循环的第二个条件`arr[preIndex] > current`，说明当前的preIndex已经不再大于current，也就是说现在的preIndex对应的是1。

你能把2插入到1的位置吗？不能，所以只能插入到1往后一个位置，也就是原来的3的位置。

最后说一说`preIndex >= 0`其实就是过滤第一个元素，索引为0的时候不执行插入排序。

#### 注意

`current := arr[i]`这句一定要加，因为你插入排序之后，原来的i的位置已经被占了，所以需要一个tmp来保留原来i的值。

```
func insertionSort(arr []int) []int {
	for i := range arr {
		preIndex := i - 1
		current := arr[i]
		for preIndex >= 0 && arr[preIndex] > current {
			arr[preIndex+1] = arr[preIndex]
			preIndex--
		}
		arr[preIndex+1] = current
	}
	return arr
}
```

另一种写法

```
func insertSort(nums []int) {
	for i := 0; i < len(nums); i++ {
		key := nums[i]
		j := i - 1
		for j >= 0 && nums[j] > key {
			nums[j+1] = nums[j]
			j--
		}
		nums[j+1] = key
	}
}
```

## 希尔排序

所谓的希尔排序其实就是建立在插入排序的基础上的，所以这里我的代码没有完全按照 geeks 来，而是自己尽量按照插入排序改，这样能够减少记忆量。

#### 算法

![1024555-20161128110416068-1421707828](C:\Users\78478\Desktop\review\1024555-20161128110416068-1421707828.png) 

#### 代码

```
func shellSort(arr []int) {
	n := len(arr)
	gap := n / 2
	for gap > 0 {
		for i := gap; i < n; i += 1 {
			tmp := arr[i]
			j := i - gap
			for j >= 0 && arr[j] > tmp {
				arr[j+gap] = arr[j]
				j -= gap
			}
			arr[j+gap] = tmp
		}
		gap /= 2
	}
}
```

## 归并排序

先拆分

后排序

```
func mergeSort(nums []int) {
	cut(nums, 0, len(nums)-1)
}

func cut(nums []int, left, right int) {
	mid := left + (right-left)/2
	if left < right {
		cut(nums, left, mid)
		cut(nums, mid+1, right)
	}
	var L, R []int

	for i := left; i <= mid; i++ {
		L = append(L, nums[i])
	}
	for i := mid + 1; i <= right; i++ {
		R = append(R, nums[i])
	}
	merge(nums, L, R, left, right)
}

func merge(nums, L, R []int, left, right int) {
	var i, j int
	k := left
	for k <= right && i < len(L) && j < len(R) {
		if L[i] <= R[j] {
			nums[k] = L[i]
			i++
		} else {
			nums[k] = R[j]
			j++
		}

		k++
	}

	for i < len(L) {
		nums[k] = L[i]
		i++
		k++
	}
	for j < len(R) {
		nums[k] = R[j]
		j++
		k++
	}
}
```

另一种写法

```
func mergeSort(nums []int, start, end int) {
	if start < end {
		mid := start + (end-start)/2
		mergeSort(nums, start, mid)
		mergeSort(nums, mid+1, end)
		merge(nums, start, mid, end)
	}
}
func merge(nums []int, l, m, r int) {
	n1, n2 := m-l+1, r-m
	L := make([]int, n1)
	R := make([]int, n1)

	for i := 0; i < n1; i++ {
		L[i] = nums[l+i]
	}
	for i := 0; i < n2; i++ {
		R[i] = nums[m+1+i]
	}
	i, j, k := 0, 0, l
	for i < n1 && j < n2 {
		if L[i] <= R[j] {
			nums[k] = L[i]
			i++
		} else {
			nums[k] = R[j]
			j++
		}
		k++
	}
	for i < n1 {
		nums[k] = L[i]
		i++
		k++
	}

	for j < n2 {
		nums[k] = R[j]
		j++
		k++
	}
}
```

## 桶排序

先看这个，它不是桶排序，但是思想类型，桶排序在它的思想之上  https://wiki.jikexueyuan.com/project/easy-learn-algorithm/bucket-sort.html 

#### 基本思想

桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。

桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（此处可以使用别的排序算法，最好是稳定的，比如插入排序等）。

1. 设置固定空桶数
2. 将数据放到对应的空桶中
3. 将每个不为空的桶进行排序
4. 拼接不为空的桶中的数据，得到结果

排序过程：
[![IMAGE](http://changyukang.github.io/2016/06/16/Programming/Algorithm_and_Data_Structure/Sorting/%E6%A1%B6%E6%8E%92%E5%BA%8F%20Bucket%20Sort%20(Distribution%20Sort)/resources/18102EBEE7438AF7C3A0D844D84E464B.jpg)](http://changyukang.github.io/2016/06/16/Programming/Algorithm_and_Data_Structure/Sorting/桶排序 Bucket Sort (Distribution Sort)/resources/18102EBEE7438AF7C3A0D844D84E464B.jpg)

#### 步骤

虽然算法那么描述，但是毛！！其实真正代码实现起来是有出入的，上来都说有几个几个桶，毛！！都是给了桶的容量，然后根据容量求桶的数量

1. 给定一个数组arr和桶的容量bucketSize，求出数组中的最大值max和最小值min。

2. 根据1中求出来的max和min，可以进一步求桶的数量bucketCount的公式：
   $$
   bucketCount=(max - min)/bucketSize + 1
   $$

3. 桶的数量确定之后，对于每一个arr中的数需要确定它在哪一个桶中（类似于哈希算法），所以arr[i]的在桶中的索引index为：
   $$
   index = (arr[i] - min) / bucketSize
   $$

4. 对每个桶进行排序，这个排序需要说一下，网上大多数做法都是随便用一个简单的排序，快速选择排序，冒泡，所以这里随意即可，我是用了golang原生包的排序。

5. 排序完，就按照桶从小到大把arr给改了，对！直接改arr中的值，不需要交换什么之类的，直接改。

#### 数据结构

根据上面的图片以及算法描述，我们可以看出来数据结构是一种二维数组，严格来讲，外面一维是数组，每个数组里的元素是切片，也就是说桶的个数是固定的，然后桶里面的数据是不确定，不固定的。

#### 代码

```
//bucketSize 桶的容量
func bucketSort(arr []int, bucketSize int) {
	if arr == nil {
		return
	}
	min, max := arr[0], arr[0]
	//求最大最小值
	for i := 1; i < len(arr); i++ {
		if arr[i] < min {
			min = arr[i]
		}
		if arr[i] > max {
			max = arr[i]
		}
	}

	//计算桶的个数
	bucketCount := (max-min)/bucketSize + 1

	//按照桶的个数初始化桶
	buckets := make([][]int, bucketCount)

	for i := 0; i < len(arr); i++ {
		//计算arr[i]位于哪个桶
		index := (arr[i] - min) / bucketSize
		buckets[index] = append(buckets[index], arr[i])
	}
	arrIndex := 0
	for i := 0; i < bucketCount; i++ {
		//对桶内的数据进行排序
		sort.Ints(buckets[i])
		//然后顺便把排好序的数据填入arr
		for j := 0; j < len(buckets[i]); j++ {
			arr[arrIndex] = buckets[i][j]
			arrIndex++
		}
	}
}
```

## 复杂度和稳定性

![](C:\Users\78478\Desktop\review\311436_1552474444160_93CF294B0FB45C83DC616C5700184F2E.png)