## http状态码

*一句话，写再多记不住白搭*

#### 201 Created （已创建）

- 响应结果：该请求已成功，并因此创建了一个新的资源。
- 使用场景：作为PUT请求的返回值。

### 204 No Content (没有内容)

- 响应结果：服务器成功处理了客户端请求，但服务器无返回内容。204是HTTP中数据量最少的响应状态，204的**响应中没有body**，而且Content-Length=0。
- 使用场景：204状态在一些网站分析的代码中**最常用**到，只需要把客户端的一些信息提交给服务器而无需关心响应。

### 301 Moved Permanently（永久性重定向)

- 响应结果：表示请求的资源已被分配了新的URL，以后应使用现在所指的URL。也就是说如果已经吧资源对应的URL保存为书签了，这时应该按Location首部字段提示的URL重新保存。
- 使用场景：
- - 域名到期不想续费（或者发现了更适合网站的域名），想换个域名。
- - 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。
- - 空间服务器不稳定，换空间的时候。

### 302 Found（临时性重定向）

- 响应结果：该状态码表示请求的资源已被分配了新的URL，希望用户（本次）能使用新的URL访问。
- 使用场景：尽量使用301！

### 304 Not Modified 

 字面意思是：资源未改变，可直接使用缓存。 

这种响应一般是GET请求中带有附加条件，例如请求头中含有if-Match,if-Modified-Since等（if-Match表示只请求带有特殊标记的资源，if-Modified-Since表示请求指定时间后未变更的资源，因为本文主要讲解状态码，所以不在此引入太多http头部的相关内容，这里是为了简单解释下附加条件请求的含义）。

 这种情况下，**服务端不会返回响应主体**，含义就是：”**从你上次访问以来这个资源都没变过哟，直接使用你本地的缓存就行啦**“。 

304就是3xx里面的一个特例，因为它不算是一个重定向。（一般我们认为重定向要给出一个新的地址让客户端去访问，304如果一定要解释为重定向，只能解释为让客户端转去访问缓存-_-）

### 401 Unauthorized（未授权）

- 响应结果：表示发送的请求需要有通过HTTP认证的认证信息。另外若之前已进行过一次请求，则表示用户认证失败。返回含有401响应必须包含一个适用于被请求资源的WWW-Authenticate 首部用以质询用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。

- 出现原因：客户端错误，指的是由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。

### 403 Forbidden （禁止）

- 响应结果：对请求资源的访问服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主题部分对原因进行描述，这样就能让用户看到了。
- 出现原因：未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源IP地址试图访问）等列举情况都可能是发生403的原因。

###  502 Bad Gateway 

作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。这里说明下网关和代理服务器的概念：前面我们举例子都是直接客户端向服务器发请求，实际上客户端有时候不是直接向服务器请求，这中间可能存在网关和代理。画个简单的图：

![图片描述](https://segmentfault.com/img/bVbo0GE?w=924&h=378) 

###  503 Service Unavailable 

 服务器暂时无法使用，可能是维护或者升级，反正无法使用。 

###  504 Gateway Timeout 

作为网关或者代理工作的服务器访问超时。

## ARQ协议

也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组 

#### ARQ协议是什么？

**自动重传请求**（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用**确认**和**超时**这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。

#### 根据arq协议可以延申出停止等待和连续arq协议

## 停止等待ARQ协议 

- 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组； 
- 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；

## 连续ARQ协议

连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

## 各层对应协议

```
 每一层的协议如下：
 物理层：RJ45、CLOCK、IEEE802.3    （中继器，集线器）
 数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机）
 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）
 传输层：TCP、UDP、SPX
 会话层：NFS、SQL、NETBIOS、RPC
 表示层：JPEG、MPEG、ASII
 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS
 每一层的作用如下：
 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
 数据链路层：将比特组装成帧和点到点的传递（帧Frame）
 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
 会话层：建立、管理和终止会话（会话协议数据单元SPDU）
 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
```

![xRetNGDfwszGt7Vx](C:\Users\78478\Desktop\review\xRetNGDfwszGt7Vx.png)

## 常用端口

```
20,21：FTP
22：SSH
23：Telnet
25：SMTP
53：DNS（UDP）
69：TFTP（类似FTP）
80：HTTP
443：HTTPS
1080：socks代理服务
8080：用户www代理服务
```

## 不同体系结构

![4039680_1523328907031_09DD8C2662B96CE14928333F055C5580](C:\Users\78478\Desktop\review\4039680_1523328907031_09DD8C2662B96CE14928333F055C5580.png)

## HTTPS加密过程

 最新推出的TLS协议，是SSL 3.0协议的升级版

 https://mp.weixin.qq.com/s?__biz=MzA5MzY4NTQwMA==&mid=2651008910&idx=4&sn=049fa10eecb3de61b98d7f58bbb78f74&chksm=8bad9c79bcda156fc2097361977595d4a19a56ded9c8b1ca55890bfe800db0551b1723f2d7b9&mpshare=1&scene=24&srcid=08287mXFO8ufu50J99Dwdfcp&sharer_sharetime=1566958392180&sharer_shareid=21a49bdfc44694f7d1e3ef9964b3998f#rd 

1. 客户端请求服务器获取证书**公钥**。
2. 客户端(SSL/TLS)解析证书（无效会弹出警告）。
3. 客户端生成随机值（这个随机值就是密钥）。
4. 客户端用公钥加密密钥，发送给服务器。
5. 服务端用私钥解密密钥得到随机值（密钥）。---从此以后就用密钥通信
6. 将信息和随机值混合在一起进行对称加密。
7. 将加密的内容发送给客户端。
8. 客户端用秘钥解密信息。

## TCP KeepAlive 原理

TCP KeepAlive 的基本原理是，**隔一段时间给连接对端发送一个探测包**，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。 

## PING 的过程/实现

有用:https://blog.csdn.net/guoweimelon/article/details/50859658

#### 过程

网上有说了一大堆的：https://juejin.im/post/6844903823643770894   https://zhuanlan.zhihu.com/p/45110873

但是核心就两个：

1. 创建 ICMP 报文（这里要表明，ping 基于 ICMP 协议的实现）。
2. 将 ICMP 报文发送给对面。

#### 为什么不需要端口

人家在网络层，运输层才需要端口，网络层不需要端口。

#### ICMP 内容

1. 类型
2. 代码
3. 校验和
4. 标识符
5. 序列号

```
type ICMP struct {
	Type        uint8
	Code        uint8
	CheckSum    uint16
	Identifier  uint16
	SequenceNum uint16
}
```

## 如何处理粘包问题

https://www.v2ex.com/t/478610

通常会有以下一些常用的方法：

1. 使用带**消息头的协议**、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该**长度**的内容。（消息头带长度）
2. 设置**定长消息**，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，**空位补上固定字符**。
3. 设置**消息边界**，服务端从网络流中按消息编辑分离出消息内容，**一般使用‘\n ’**。
4. 更为复杂的协议，例如楼主最近接触比较多的车联网协议 808,809 协议。x

## http格式

#### Get 请求格式

粗略地讲就是：请求行，请求头，请求实体。

## 滑动窗口（复盘）

https://blog.csdn.net/yajie_china/article/details/88286426

https://juejin.im/post/6844904105211592712

工作的过程看这个，但是这个没有解决滑动窗口大小是怎么来的 http://www.52im.net/thread-515-1-1.html

这个复习主要是解决接收端是怎么求出滑动窗口大小的。

#### 工作原理

接收端会**回复给发送端的 tcp 报文中**有个 `window` 字段，**这个字段（window）就是发送端的滑动窗口大小**。

接收端中**还剩可以发送的数据** = **发送窗口（接收端给的）** 减去  **已经发送但是没 ack 的**。

![](C:\Users\78478\Desktop\review\101120ihanzfsth0hhcllk.png)

一旦发送端收到 ack，发送窗口就向前滑动 ack 了多少的距离，同时发送窗口的大小要跟这次 ack 中传过来的 window 字段一样。这里就是这次复习的重点，假如发送窗口的大小真的变了（其实就应该是变得，哪里有可能每次都一样，但是很多资料都忽视了这点）。

![](C:\Users\78478\Desktop\review\104938yhzgro73pypszrop.png)

假如接收窗口也就是window变了，那么接收端往前滑动，但是发送窗口的大小也要变，也就是滑动的过程中缩短（自己想象一下，**它往前滑，同时又不断缩短**）。

#### 滑动窗口的大小

其实所谓的滑动窗口就是 **tcp 的缓冲区空闲大小**，知识 tcp 的缓冲区大小因为接收到了数据，而现在有可能用户端还没有处理这个数据。

```
假如现在 tcp 缓冲区的大小是 100，接收了 80 并且没有立马处理，那么滑动窗口的大小就剩下 20，回复给发送端的发送窗口就只有 20。
```

http://www.52im.net/thread-515-1-1.html 可以注意到这个连接中，其实滑动窗口的大小是在不断变小的，其实就是 **接收能力大 > 处理能力**，但是他妈的它居然没有说出来

所以，**window = tcp 缓冲区 - 还没有处理的数据**。

#### 总结

所以，在传输的过程中，接收端要不断告知 window，然后**发送端不仅要滑动窗口**，**同时窗口大小也在不断变动**，这个**窗口的大小**就是现在接收端的 **tcp 缓冲区的空闲大小**。

#### 模拟过程

很丑，自己随便画的，每个过程都假设接收端没有能力立马处理数据，所以 tcp 缓冲区开始积累，之后处理了 tcp 缓冲区空闲的部分立马增多。

<img src=" C:\Users\78478\Desktop\review\微信图片_20200911040041.jpg" style="transform:rotate(90deg);margin:120px">

## dns解析过程？解析用tcp还是udp？

#### 域名的分类

有关域名的讲解：http://www.ruanyifeng.com/blog/2016/06/dns.h

1. 根域名
2. 顶级域名
3. 次级域名

一般的地址应该为：`www.baidu.com.root`，最后应该是有root，这个就叫做根，大家都一样所以省略，然后是com是顶级域名，然后是baidu的次级域名，tml

#### 过程

解析过程：https://zhuanlan.zhihu.com/p/38499577

一开始**客户端访问本地 dns 服务器**是**递归查询**，**后面**都是**迭代查询**。

查询的过程，分成递归查询和迭代查询，如下图所示，一级一级往下查。

 ![img](https://pic1.zhimg.com/80/v2-a8f29e5de931a58e10d72c8b1020dc68_1440w.jpg) 

#### udp 还是 tcp

域名查询时采用udp，区域传送时采用tcp

#### 递归查询

什么是递归查询，**就是本地 dns 服务器帮客户端查询**，客户端自己不用干活，也就是第一步是递归查询。

#### 迭代查询

什么是迭代查询？**就是每次都要本地 dns 服务器自己去查**，dns 除了第一次其他都是本地 dns 服务器去查询，例如去查根域名服务器，去查顶级域名服务器之类的。

#### DNS区域传送

**DNS区域传送**（**DNS zone transfer**）指的是一台备用服务器使用来自主服务器的数据刷新自己的域（zone）数据库。这为运行中的DNS服务提供了一定的冗余度，其目的是为了防止主的域名服务器因意外故障变得不可用时影响到整个域名的解析。 

区域传送可以理解成主从复制，从服务器要更新数据，数据量庞大，这时候就要确保数据不丢失。

## 验证 https 证书

https://juejin.im/post/6844903545272041479

https://www.zhihu.com/question/37370216

验证 https 证书包括验证其**可信性**和**有效性**，看面试官说哪一种

#### 可信性

浏览器（操作系统）内置了**根证书**，我们浏览的页面的证书叫做站点证书，如果站点证书是可信的，那么**证书应该是由根证书或者根证书的二级证书机构颁布的**。我们要验证的就是这条证书链的源头是不是根证书。

我们要验证当前证书，就需要知道 ca 公钥，而公钥在当前证书的上一级，而要验证上一级就需要知道上一级的上一级，最终找到根证书这里，因为根证书的公钥在根证书自己那里。所以最后变成了我们验证根证书的可信性。

如何验证根证书的可信性？

前面说过，根证书浏览器有，所以根证书的公钥我们也有，**当前证书**内部有**签名**，我们用**根证书的公钥解开这个签名**，得到**摘要**，我们再把证书内容进行进行散列计算得到一个 hash 值。然后比较两个值是否相等。

#### 有效性

***CRL***，***证书撤销名单*** ，证书颁发者会提供一份已经失效的名单，浏览器会缓存，然后定期更新。离线文件

***OCSP***， ***在线证书状态协议*** ，证书颁发者也会提供实时的查询接口，查询某个特定证书目前是否有效。 

## 子网划分

https://www.nowcoder.com/questionTerminal/aae2457a009a4a55964c66fe5785d6f4?toCommentId=436177

 对于C类地址来说，前24位为网络号，后8位为主机号。
划分子网的方法是**从网络的主机号借用若干位作为子网号**，将两级IP地址变为三级IP地址。
转变后的地址格式为： 

  ![img](https://uploadfiles.nowcoder.com/files/20180618/6801621_1529323421623_equation?tex=IP%E5%9C%B0%E5%9D%80%20%3A%3A%3D%20%5Cleft%5C%7B%20%3C%E7%BD%91%E7%BB%9C%E5%8F%B7%3E%EF%BC%8C%3C%E5%AD%90%E7%BD%91%E5%8F%B7%3E%EF%BC%8C%3C%E4%B8%BB%E6%9C%BA%E5%8F%B7%3E%20%5Cright%5C%7D) 

  

   该题要求将网络划分为20个子网，  

   因为![img](https://uploadfiles.nowcoder.com/files/20180618/6801621_1529323329687_equation?tex=2%5E%7B5%7D%3D32%3E20)，所以至少需要从主机号中借用**5**位作为子网号才能满足所需子网数。  

 子网掩码中的**1****24****5**

子网掩码中的**0**对应于现在的**3**位主机号。  

 所以，最终求得的子网掩码为：
![img](https://uploadfiles.nowcoder.com/files/20180618/6801621_1529323532691_equation?tex=11111111%E3%80%8011111111%E3%80%8011111111%E3%80%8011111000%20%5CRightarrow%20255.255.255.248)

