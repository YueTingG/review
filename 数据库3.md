## 可重复读能不能避免幻读

https://www.codenong.com/cs107121470/

结论：绝大部分情况下可以避免幻读，但是部分情况下不能避免幻读。

#### 快照读

事务 A 快照读1，事务 B 插入（无论B是否提交，哪怕提交了），A 快照读2。

则 1 和 2 的结果是一样的。

![](C:\Users\78478\Desktop\review\20200704112137106.png)

注意，里面说的是 A 提交后事务结束能看见。

#### 当前读

A 使用当前读1（for update 上锁），B 插入失败，阻塞到超时，或者A提前 commit 解锁，B 就不会失败。

可以这么说，当你使用 for update 的时候，不是这一瞬间加锁，而是从这以后一直锁着，直到事务结束（可能有其他方式解锁）

所以 for update 就是加锁，而且不是一瞬间的事情，是直到这个事务结束以前都会一直锁着。

![](C:\Users\78478\Desktop\review\20200704112753472.png)

#### 部分总结

从上面例子中我们不难得出，仅仅从快照读和当前读的角度来说，其实是能够避免幻读的情况的，快照读本身有 mvcc 的机制，这种机制当中的 read view 只生成一次，能够保证可读的数据至始至终都一样。

而当前读有 next-key 锁，会把范围的数据锁住，让其他事务阻塞，直到我当前事务提交，这两种方式都可以避免幻读。

#### 例外

A 快照读1，B 插入一行，A 范围修改修改到了 B 插入的一行，A快照读2。

1 和 2不一样，出现幻读。

![](C:\Users\78478\Desktop\review\20200704115039369.png)

## 覆盖索引

https://www.cnblogs.com/myseries/p/11265849.html

#### 覆盖索引

什么是覆盖索引，在一颗索引树上就能能获取 sql 所需的全部列，无需回表，就是覆盖索引。

#### 回表

我们在辅助索引的叶子节点中存储的是 id 的聚集索引，相当于查完辅助索引之后，还要跑到主键索引那里再去查一次，这称之为**回表**。

但是如果要查的字段只是**辅助索引的字段+主键**（这个很重要），那么不需要回表。

#### 如何达到覆盖索引/回表的解决方法

联合索引，具体看连接

## 联合索引/聚合索引

最左前缀

## 索引下推