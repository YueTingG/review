---
typora-root-url: ./
---

## 可重复读能不能避免幻读

https://www.codenong.com/cs107121470/

结论：绝大部分情况下可以避免幻读，但是部分情况下不能避免幻读。

#### 快照读

事务 A 快照读1，事务 B 插入（无论B是否提交，哪怕提交了），A 快照读2。

则 1 和 2 的结果是一样的。

![](C:\Users\78478\Desktop\review\20200704112137106.png)

注意，里面说的是 A 提交后事务结束能看见。

#### 当前读

A 使用当前读1（for update 上锁），B 插入失败，阻塞到超时，或者A提前 commit 解锁，B 就不会失败。

可以这么说，当你使用 for update 的时候，不是这一瞬间加锁，而是从这以后一直锁着，直到事务结束（可能有其他方式解锁）

所以 for update 就是加锁，而且不是一瞬间的事情，是直到这个事务结束以前都会一直锁着。

![](C:\Users\78478\Desktop\review\20200704112753472.png)

#### 部分总结

从上面例子中我们不难得出，仅仅从快照读和当前读的角度来说，其实是能够避免幻读的情况的，快照读本身有 mvcc 的机制，这种机制当中的 read view 只生成一次，能够保证可读的数据至始至终都一样。

而当前读有 next-key 锁，会把范围的数据锁住，让其他事务阻塞，直到我当前事务提交，这两种方式都可以避免幻读。

#### 例外

A 快照读1，B 插入一行，A 范围修改修改到了 B 插入的一行，A快照读2。

1 和 2不一样，出现幻读。

![](C:\Users\78478\Desktop\review\20200704115039369.png)

## 覆盖索引

https://www.cnblogs.com/myseries/p/11265849.html

#### 覆盖索引

什么是覆盖索引，在一颗索引树上就能能获取 sql 所需的全部列，无需回表，就是覆盖索引。

#### 回表

我们在辅助索引的叶子节点中存储的是 id 的聚集索引，相当于查完辅助索引之后，还要跑到主键索引那里再去查一次，这称之为**回表**。

但是如果要查的字段只是**辅助索引的字段+主键**（这个很重要），那么不需要回表。

#### 如何达到覆盖索引/回表的解决方法

联合索引，具体看连接

## 联合索引/聚合索引

#### 最左前缀

https://juejin.im/post/6844904073955639304

https://my.oschina.net/u/945573/blog/2985834

#### 模糊查询

#### 覆盖索引

## 索引下推

https://juejin.im/post/6844904110072791048

## mysql acid 特性的实现（有时间面试会问成事务的实现）

https://www.cnblogs.com/kismetv/p/10331633.html# 讲得非常好

大部分我之前都已经掌握了，但是少了汇总，链接里面就相当于把他们全部汇总了起来

我单独拿一致性来讲讲

#### 一致性的概念

>  [Consistency](https://en.wikipedia.org/wiki/Consistency_(database_systems)) ensures that a transaction can only bring the database from one valid state to another, maintaining database [invariants](https://en.wikipedia.org/wiki/Invariant_(computer_science)): any data written to the database must be valid according to all defined rules, including [constraints](https://en.wikipedia.org/wiki/Integrity_constraints), [cascades](https://en.wikipedia.org/wiki/Cascading_rollback), [triggers](https://en.wikipedia.org/wiki/Database_trigger), and any combination thereof. This prevents database corruption by an illegal transaction, but does not guarantee that a transaction is *correct*. [Referential integrity](https://en.wikipedia.org/wiki/Referential_integrity) guarantees the [primary key](https://en.wikipedia.org/wiki/Unique_key) – [foreign key](https://en.wikipedia.org/wiki/Foreign_key) relationship. [[6\]](https://en.wikipedia.org/wiki/ACID#cite_note-Date2012-6) 

翻译一下，大概就是（谷歌渣翻）：

 [一致性](https://en.wikipedia.org/wiki/Consistency_(database_systems))确保事务只能将数据库从一种有效状态转移到另一种有效状态，并保持数据库[不变性](https://en.wikipedia.org/wiki/Invariant_(computer_science))：根据所有定义的规则（包括[约束](https://en.wikipedia.org/wiki/Integrity_constraints)，[级联](https://en.wikipedia.org/wiki/Cascading_rollback)，[触发器](https://en.wikipedia.org/wiki/Database_trigger)及其任何组合），写入数据库的任何数据都必须有效。这可以防止数据库因非法交易而损坏，但不能保证交易*正确无误*。[参照完整性](https://en.wikipedia.org/wiki/Referential_integrity)保证了[主键](https://en.wikipedia.org/wiki/Unique_key)-[外键](https://en.wikipedia.org/wiki/Foreign_key)关系。 

说人话就是：**数据库在事务执行前后都保持一致性状态**。 

#### 一致性包含的内容

（网上有人主张只包含第一种，但是我自己倾向于应用层也是考虑范围，但是实际上当你跳脱出概念，你会发现很没有所谓，因为现实生活我们就是要考虑应用层的一致性，所以不拘泥于概念）

一致性包括：

1. **数据库系统本身的一致性**
2. 程序员负责的**应用层一致性**。

数据库系统**本身**的一致性就是**完整性约束**。

#### 数据库的完整性

1. [实体完整性](https://zh.wikipedia.org/wiki/實體完整性)，同一数据表中不可有多项记录拥有相同识别（**实体完整性要求每一张表都有主键**，前面一句话的意思就是，你得有个唯一识别的东西，那这个东西就是主键）。
2. 域完整性，限制字段中的数据必须乎合预设的数据类型，例如：日期。（域完整性就是指列，就是指**列的类型，大小，长度必须符合定义**，例如，你不能把 varchar 赋值给 int）
3. 参照完整性，如两个数据表是有关联的，父数据表中的记录必须存在，子数据表的记录才有存在。（**外键约束**）

所以，遵守数据库系统本身的一致性，你就要保证执行完事务前后，表的主键，列的类型，大小等，然后外键是否有问题，而这些其实数据库本身已经实现好了。

所以我们实际上就是要遵守应用层的一致性。

#### 应用层的一致性

简单讲，就是用转账的例子举例，你给 a 转账，总的钱数要相同，不能说转完帐（事务结束）之后，系统总的钱数少了。

另外，我规定了某个字段只能有 1-3，但是我给他赋值 100，从数据库本身来讲，他符合完整性，他还是 int，大小什么的也没错，但是他不符合我们的业务含义，我目前并没有规定 100 的业务。

## 数据库的锁

![](Screenshot1520500121 (1).png)

## 意向锁

https://juejin.cn/post/6844903666332368909

#### 意向锁的概念

意向锁其实很简单，就是在你加锁（排它锁和共享锁）之前，先加一把锁，然后他没有特定的命令，他会在你执行以下命令之前，**自动**地给你加意向锁。

```
-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。
SELECT column FROM table ... LOCK IN SHARE MODE;

-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。
SELECT column FROM table ... FOR UPDATE;
```

#### 为什么要有意向锁

假如，我事务 a 加了**排它锁**

```
SELECT * FROM users WHERE id = 6 FOR UPDATE; 
```

然后，事务 b 加了 user **表锁**级别的**共享锁**（表锁级别的，注意命令不是 lock in share mode）

（注意以下命令是表锁）

```
LOCK TABLES users READ; // 表锁的共享锁
```

然后，我们知道排它锁和共享锁是互斥的嘛，所以如果 b 要加锁成功，那么首先要保证

1. user 表整张表没有**表锁**级别的**排它锁**。（行锁要看是否同一行）
2. user **任意一行**没有**行锁**级别的**排它锁**。

其中，第 2 点你需要遍历每一行来判断是否有排它锁，很麻烦，所以引入了意向锁。

在有意向锁的情况下，上面的判断就变成：

1. 不变
2. user 表是否存在意向锁，如果存在意向锁，那么数据库中**某一行**加了**排它锁**。

其实，我们可以看到，意向锁就是为了**防止**是否加锁时的**遍历判断**，即不用你一行行去遍历看看是否加了锁。

#### 意向锁之间的兼容性

|                      | 意向共享锁（IS） | 意向排他锁（IX） |
| -------------------- | ---------------- | ---------------- |
| **意向共享锁（IS）** | 兼容             | 兼容             |
| **意向排他锁（IX）** | 兼容             | 兼容             |

意向锁之间兼容，不互斥

#### 意向锁和互斥，排它锁之间的兼容性

|                 | 意向共享锁（IS） | 意向排他锁（IX） |
| --------------- | ---------------- | ---------------- |
| **共享锁（S）** | 兼容             | 互斥             |
| **排他锁（X）** | 互斥             | 互斥             |

**注意**：这里的共享锁和排它锁都是**表锁**

**注意**：这里的共享锁和排它锁都是**表锁**

**注意**：这里的共享锁和排它锁都是**表锁**

（说 3 遍）

**意向锁和行锁不互斥**

**意向锁和行锁不互斥**

**意向锁和行锁不互斥**

所以，行锁之间是否互斥，要看锁住的是否是同一行。

#### 总结/运用

通过上面我们可以发现，什么时候使用到意向锁，或者说意向锁是用在什么地方？

当我们就是需要给一张表**加表锁**的时候，而我们**这张表上存在行锁**，而我们又不知道具体哪一行加了行锁的时候，这个时候我们要想到意向锁。

然而实际上，这只是一个知识，在实践中，你不需要加意向锁，数据库会自动加锁，懂这个知识只是面试用的。

## next-key

https://www.v2ex.com/t/538916 看里面的讨论

https://www.cnblogs.com/zhoujinyi/p/3435982.html

#### 理解

首先，我们知道 next-key 等于 gap lock +  record lock，也就是说，next-key 等于间隙锁+行锁。

行锁我们知道，就是锁住**等值查询**（有索引）的时候的某一行。

那间隙锁呢？除了像

```
select * from user id > 2
```

会锁住 id>2 的间隙，这种间隙有什么特点？

1. id 是主键（唯一索引）
2. 不是等值查询。

这种是最直观的范围。

还有一种，看下一个 h4

#### 当等值查询不是唯一索引（主键索引）的时候

我们建表

```sql
CREATE TABLE `ttt` (
  `id` varchar(18) NOT NULL DEFAULT '',
  `gap` int NOT NULL ,

  PRIMARY KEY (`id`),
  KEY `gap` (`gap`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='ccc_11332234';

insert into `ttt` values ('1',1);
insert into `ttt` values ('3',3);
insert into `ttt` values ('5',5);
insert into `ttt` values ('7',7);
insert into `ttt` values ('9',9);

start transaction;

## 锁住 gap = 3，gap 是辅助索引
select * from `ttt` where `gap`=3 for update; 
```

这个时候，从概念上，会产生 (-无穷,1] (1,3] (3,5] (5,7] 这些区间，因为 gap = 3，所以 next-key locking 会锁住 (1,3]，以及下一个区间(3,5]（所谓的 next-key）

此时，你不能插入一条 gap =3，或者 gap=4也就是 (1,5]区间内的值。

注意，哪怕不提 (1,5]这个区间，gap = 3锁住的也是一个区间，为什么这么说？因为 gap 这个索引并不是一个唯一索引，它可以有诸如 values('31',3)，values('32',3)，values('33',3)之类的行，但是不可以有 values('3', 4)这样的行，后者违反主键唯一。

所以 gap=3，是可以产生很多数据的，在其他事务上，如果没有间隙锁，此时是可以插入 gap=3 的任意数据的，这时候，如果再执行当前查，那么就会产生幻读。

**注意**：gap = 3要联想到gap 这颗索引树，它会锁住 gap =3 满足这个条件的所有结点（行），这些结点（行）是复数的。而假如 id = 3，id 是唯一索引，id = 3 没有复数的结点（行）。

#### 结论

https://www.jianshu.com/p/d5c2613cbb81 可以看下，最后文中的结论部分

所以，一提到间隙锁，除了唯一索引的范围查询，在**等值查询使用到了辅助索引**的时候，照样是会产生间隙锁的。

另外一个需要注意的地方，当主键的等值查询没有命中的时候，也会产生间隙锁。