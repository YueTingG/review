## 可重复读能不能避免幻读

https://www.codenong.com/cs107121470/

结论：绝大部分情况下可以避免幻读，但是部分情况下不能避免幻读。

#### 快照读

事务 A 快照读1，事务 B 插入（无论B是否提交，哪怕提交了），A 快照读2。

则 1 和 2 的结果是一样的。

![](C:\Users\78478\Desktop\review\20200704112137106.png)

注意，里面说的是 A 提交后事务结束能看见。

#### 当前读

A 使用当前读1（for update 上锁），B 插入失败，阻塞到超时，或者A提前 commit 解锁，B 就不会失败。

可以这么说，当你使用 for update 的时候，不是这一瞬间加锁，而是从这以后一直锁着，直到事务结束（可能有其他方式解锁）

所以 for update 就是加锁，而且不是一瞬间的事情，是直到这个事务结束以前都会一直锁着。

![](C:\Users\78478\Desktop\review\20200704112753472.png)

#### 部分总结

从上面例子中我们不难得出，仅仅从快照读和当前读的角度来说，其实是能够避免幻读的情况的，快照读本身有 mvcc 的机制，这种机制当中的 read view 只生成一次，能够保证可读的数据至始至终都一样。

而当前读有 next-key 锁，会把范围的数据锁住，让其他事务阻塞，直到我当前事务提交，这两种方式都可以避免幻读。

#### 例外

A 快照读1，B 插入一行，A 范围修改修改到了 B 插入的一行，A快照读2。

1 和 2不一样，出现幻读。

![](C:\Users\78478\Desktop\review\20200704115039369.png)

## 覆盖索引

https://www.cnblogs.com/myseries/p/11265849.html

#### 覆盖索引

什么是覆盖索引，在一颗索引树上就能能获取 sql 所需的全部列，无需回表，就是覆盖索引。

#### 回表

我们在辅助索引的叶子节点中存储的是 id 的聚集索引，相当于查完辅助索引之后，还要跑到主键索引那里再去查一次，这称之为**回表**。

但是如果要查的字段只是**辅助索引的字段+主键**（这个很重要），那么不需要回表。

#### 如何达到覆盖索引/回表的解决方法

联合索引，具体看连接

## 联合索引/聚合索引

#### 最左前缀

https://juejin.im/post/6844904073955639304

https://my.oschina.net/u/945573/blog/2985834

#### 模糊查询

#### 覆盖索引

## 索引下推

https://juejin.im/post/6844904110072791048

## mysql acid 特性的实现

https://www.cnblogs.com/kismetv/p/10331633.html# 讲得非常好

大部分我之前都已经掌握了，但是少了汇总，链接里面就相当于把他们全部汇总了起来

我单独拿一致性来讲讲

#### 一致性的概念

>  [Consistency](https://en.wikipedia.org/wiki/Consistency_(database_systems)) ensures that a transaction can only bring the database from one valid state to another, maintaining database [invariants](https://en.wikipedia.org/wiki/Invariant_(computer_science)): any data written to the database must be valid according to all defined rules, including [constraints](https://en.wikipedia.org/wiki/Integrity_constraints), [cascades](https://en.wikipedia.org/wiki/Cascading_rollback), [triggers](https://en.wikipedia.org/wiki/Database_trigger), and any combination thereof. This prevents database corruption by an illegal transaction, but does not guarantee that a transaction is *correct*. [Referential integrity](https://en.wikipedia.org/wiki/Referential_integrity) guarantees the [primary key](https://en.wikipedia.org/wiki/Unique_key) – [foreign key](https://en.wikipedia.org/wiki/Foreign_key) relationship. [[6\]](https://en.wikipedia.org/wiki/ACID#cite_note-Date2012-6) 

翻译一下，大概就是（谷歌渣翻）：

 [一致性](https://en.wikipedia.org/wiki/Consistency_(database_systems))确保事务只能将数据库从一种有效状态转移到另一种有效状态，并保持数据库[不变性](https://en.wikipedia.org/wiki/Invariant_(computer_science))：根据所有定义的规则（包括[约束](https://en.wikipedia.org/wiki/Integrity_constraints)，[级联](https://en.wikipedia.org/wiki/Cascading_rollback)，[触发器](https://en.wikipedia.org/wiki/Database_trigger)及其任何组合），写入数据库的任何数据都必须有效。这可以防止数据库因非法交易而损坏，但不能保证交易*正确无误*。[参照完整性](https://en.wikipedia.org/wiki/Referential_integrity)保证了[主键](https://en.wikipedia.org/wiki/Unique_key)-[外键](https://en.wikipedia.org/wiki/Foreign_key)关系。 

说人话就是：**数据库在事务执行前后都保持一致性状态**。 

#### 一致性包含的内容

（网上有人主张只包含第一种，但是我自己倾向于应用层也是考虑范围，但是实际上当你跳脱出概念，你会发现很没有所谓，因为现实生活我们就是要考虑应用层的一致性，所以不拘泥于概念）

一致性包括：

1. **数据库系统本身的一致性**
2. 程序员负责的**应用层一致性**。

数据库系统**本身**的一致性就是**完整性约束**。

#### 数据库的完整性

1. [实体完整性](https://zh.wikipedia.org/wiki/實體完整性)，同一数据表中不可有多项记录拥有相同识别（**实体完整性要求每一张表都有主键**，前面一句话的意思就是，你得有个唯一识别的东西，那这个东西就是主键）。
2. 域完整性，限制字段中的数据必须乎合预设的数据类型，例如：日期。（域完整性就是指列，就是指**列的类型，大小，长度必须符合定义**，例如，你不能把 varchar 赋值给 int）
3. 参照完整性，如两个数据表是有关联的，父数据表中的记录必须存在，子数据表的记录才有存在。（**外键约束**）

所以，遵守数据库系统本身的一致性，你就要保证执行完事务前后，表的主键，列的类型，大小等，然后外键是否有问题，而这些其实数据库本身已经实现好了。

所以我们实际上就是要遵守应用层的一致性。

#### 应用层的一致性

简单讲，就是用转账的例子举例，你给 a 转账，总的钱数要相同，不能说转完帐（事务结束）之后，系统总的钱数少了。

另外，我规定了某个字段只能有 1-3，但是我给他赋值 100，从数据库本身来讲，他符合完整性，他还是 int，大小什么的也没错，但是他不符合我们的业务含义，我目前并没有规定 100 的业务。