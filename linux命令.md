## /dev/null ：代表空设备文件

```
：代表重定向到哪里，例如：echo "123" > /home/123.txt
1  ：表示stdout标准输出，系统默认值是1，所以">/dev/null"等同于"1>/dev/null"
2  ：表示stderr标准错误
&  ：表示等同于的意思，2>&1，表示2的输出重定向等同于1
```

/tmp/test.sh > /tmp/test.log 2>&1

## 同时实现输出和错误重定向 &>/tmp/test.log 也可以满足

```
前半部分/tmp/test.sh > /tmp/test.log很容易理解，那么后面的2>&1是怎么回事呢？
要解释这个问题，还是得提到文件重定向。我们知道>和<是文件重定向符。那么1和2是什么？
在shell中，每个进程都和三个系统文件 相关联：标准输入stdin，标准输出stdout、标准错误stderr，三个系统文件的文件描述符分别为0，1、2。所以这里2>&1 的意思就是将标准错误也输出到标准输出当中。
```

##  . ./test.sh >/dev/null 1 && echo $aa 

```
第一个点就是source 写入环境变量 选项a没写入环境变量 读不到aa 
linux命令执行成功后会返回0
```

## VI命令

 vi有两种工作模式：命令模式和文本输入模式。启动vi需要输入vi，按[Spacebar]键并输入文件名后回车。 

#### 切换模式键

按***[ESC]***键使vi从文本输入模式回到命令模式。

表1列出了vi从命令模式切换到文本输入模式的命令键及其功能。

<center>表1 切换到文本输入模式的命令键</center>

| **键** | **功能**                                               |
| ------ | ------------------------------------------------------ |
| i      | 在光标左侧输入正文                                     |
| I      | 在光标所在行的行首输入正文                             |
| a      | 在光标右侧输入正文，其实就是光标向右移动了一位（实测） |
| A      | 在光标所在行的行尾输入正文                             |
| o      | 在光标所在行的下一行增添新行，光标位于新行的行首       |
| O      | 在光标所在行的上一行增添新行，光标位于新行的行首       |

#### 退出命令

只能在命令模式下使用

<center>表2 vi编辑器的退出命令</center>

| **键** | **功能**                   |
| ------ | -------------------------- |
| :wq    | 保存文件，退出vi编辑器     |
| :w     | 保存文件，但不退出vi编辑器 |
| :q     | 退出vi编辑器               |
| :q!    | 不保存文件，退出vi编辑器   |
| ZZ     | 保存文件，退出vi编辑器     |

**记忆:**w是保存，q是退出，！是强制退出。

#### 剪切和粘贴键

这些键用来重新安排用户文件中的文本，在vi的命令模式下可用。

<center> 表5 vi编辑器的剪切和粘贴键 </center>

| **键** | **功能**                                                     |
| ------ | ------------------------------------------------------------ |
| d      | 删除指定位置的文本，并存到临时的缓冲区中。可以使用put操作符（p或P键）访问这个缓冲区 |
| y      | 将指定位置的文本复制到临时缓冲区。可以使用put操作符访问这个缓冲区 |
| yy     | 复制当前行                                                   |
| P      | 将指定缓冲区的内容放到当前光标的位置之上                     |
| p      | 将指定缓冲区的内容放到当前光标的位置之下                     |

## ARP

**arp命令**用于操作主机的arp缓冲区，它可以显示arp缓冲区中的所有条目、删除指定的条目或者添加静态的[ip](http://man.linuxde.net/ip)地址与MAC地址对应关系。

#### 语法 

```
arp(选项)(参数)
```

#### 选项 

```
-a<主机>：显示arp缓冲区的所有条目；
-H<地址类型>：指定arp指令使用的地址类型；
-d<主机>：从arp缓冲区中删除指定主机的arp条目；
-D：使用指定接口的硬件地址；
-e：以Linux的显示风格显示arp缓冲区中的条目；
-i<接口>：指定要操作arp缓冲区的网络接口；
-s<主机><MAC地址>：设置指定的主机的IP地址与MAC地址的静态映射；
-n：以数字方式显示arp缓冲区中的条目；
-v：显示详细的arp缓冲区条目，包括缓冲区条目的统计信息；
-f<文件>：设置主机的IP地址与MAC地址的静态映射。
```

##  在 linux 下，如何查看物理内存的大小？ 

 **cat /proc/meminfo** 

## Proc

用户和应用程序可以通过proc得到系统的信息， cpu，内存（物理内容，别因为多了物理两个字就想到dev，照样是在proc文件下访问）

使用cat来获取对应的信息，这么理解：文件内存放信息，cat进行获取

```
cat /proc/cpuinfo cpu的信息
cat /proc/meminfo RAM使用的相关信息，内存信息
cat /proc/swaps 交换空间的使用情况，查看所有swap分区的信息
```

## du

**注意：**du查看获取的是某个文件的大小，而不能说成是获取某个硬盘的大小（这个是df的功能）

#### 命令格式

```
du [选项][文件]
```

#### 功能

```
显示每个文件和目录的磁盘使用空间。查看的是某个文件的大小
```

#### 选项

```
-s：对每个Names参数只给出占用的数据块总数。
-a：递归地显示指定目录中各文件及子目录中各文件占用的数据块数。若既不指定-s，也不指定-a，则只显示Names中的每一个目录及其中的各子目录所占的磁盘块数。
-b：以字节为单位列出磁盘空间使用情况（系统默认以k字节为单位）。
-k：以1024字节为单位列出磁盘空间使用情况。
-c：最后再加上一个总计（系统默认设置）。
-l：计算所有的文件大小，对硬链接文件，则计算多次。
-x：跳过在不同文件系统上的目录不予统计。
```

## df

#### 功能

```
df命令可以获取硬盘被占用了多少空间，目前还剩下多少空间等信息，它也可以显示所有文件系统对i节点和磁盘块的使用情况。显示的是当前文件系统下已挂载的磁盘各个分区的大小及其使用情况，就是dev下面的情况
```

#### 选项

```
  -a：显示所有文件系统的磁盘使用情况，包括0块（block）的文件系统，如/proc文件系统。
  -k：以k字节为单位显示。
  -i：显示i节点信息，而不是磁盘块。
  -t：显示各指定类型的文件系统的磁盘空间使用情况。
  -x：列出不是某一指定类型文件系统的磁盘空间使用情况（与t选项相反）。
  -T：显示文件系统类型。
```

## expr

**注意：**expr命令也常用在shell脚本中，例如其中expr length [string]就可以求字符串长度

### expr index

#### 格式

```shell
expr index [string] [substring]
# 需要解释一下，substring不是真正匹配substring，而是匹配substring中任意一个字符，并且返回它在string中最靠前的那个
```

#### 示例

```
$ expr index "abc" cb
2
# 首先，substring不论是cb还是bc都会返回2，应该这么思考，首先在"abc"中能匹配到b和c，那么接下来在“abc”中看看谁在前面，对，不是在substring中找谁在前，而是在string中发现b靠前，所以返回2。同理可以思考，只要substring中存在a，无论a在哪个位置，一定返回1，因为string中a是最靠前的
```

### expr length

#### 格式

```sh
expr length [string]
# 返回长度
```

#### 示例

```sh
expr length "abc"
# 3
```

### expr substr

#### 格式

```
expr substr [string] [from] [to]
# 返回from到to的string的子字符串，需要注意的是from和to是闭区间，[]，from和to都会返回
```

#### 示例

```
expr substr "abcd" 2 4
# bcd
```

### expr 运算

#### 示例

**注意：**表达式和运算符之间必须要空格隔开，例如2+2是不对的，应该是2 + 2，中间要空格

```
 > expr 14 % 9
 5
 > expr 10 + 10
 20
 > expr 1000 + 900
 1900
 > expr 30 / 3 / 2
 5
 > expr 30 \* 3 (使用乘号时，必须用反斜线屏蔽其特定含义。因为shell可能会误解显示星号的意义)
 90
 > expr 30 * 3
 expr: Syntax error
```

