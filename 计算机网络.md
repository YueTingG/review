面经 https://www.nowcoder.com/discuss/1937 

### 滑动窗口协议有

1、停止等待协议，发送窗口=1，接受窗口=1；

2、退后N帧协议，发送>1,接收=1;

3、选择重传协议，发送>1,接收>1;

## tcp

### 三次握手

![img](https://upload-images.jianshu.io/upload_images/1641067-8d52ca990ffbee0a.png?imageMogr2/auto-orient/strip|imageView2/2/w/839/format/webp) 

#### 三次握手：

- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 `SYN_SEND` 状态。

  首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。

- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 `SYN_RCVD` 的状态。

  在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。

- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 `ESTABLISHED` 状态。服务器收到 ACK 报文之后，也处于 `ESTABLISHED` 状态，此时，双方已建立起了连接。

  确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。

#### 为什么需要三次握手，两次不行吗？

关键字：**客户端重传**。第一次握手可能是一次失效的握手，第三次握手是对第一次握手的确认。

假如两次，也就是客户端一发送，服务端就建立连接。那么假如客户端发送两次，因为第一次滞留，那么客户端相当于建立了两次连接，但实际上第一次已经是无效的了。

如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端**，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。

### 四次挥手

![img](https://upload-images.jianshu.io/upload_images/1641067-5ed8bf6c24244b4c.png?imageMogr2/auto-orient/strip|imageView2/2/w/878/format/webp) 

#### 四次挥手的过程如下：

- 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 `FIN_WAIT1` 状态。 即发出**连接释放报文段**（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。
- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。 即服务端收到连接释放报文段后即发出**确认报文段**（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态。 即服务端没有要向客户端发出的数据，服务端发出**连接释放报文段**（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 `TIME_WAIT` 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 `CLOSED` 状态。 即客户端收到服务端的连接释放报文段后，对此发出**确认报文段**（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

### 挥手为什么需要四次

关键字：半关闭，服务端还想要发送数据

### 四次挥手释放连接时，等待2MSL的意义?

#### 两个理由：

1. 关键字：**客户端重传**，确保客户端最后一个 ACK 能够到达服务端（这个 ACK 可能丢失）

   保证客户端发送的最后一个ACK报文段能够到达服务端。 **客户端的ACK报文段有可能丢失**（**所以客户端怎么着也得重传一次，不然服务端没办法正常关闭**），使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。

2. 关键字：**已失效的连接请求报文段**

   防止“已失效的连接请求报文段”出现在本连接中。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

## TCP 对应的一些函数

![](C:\Users\78478\Desktop\review\4553977-a551f53927c2a5da.jpg)

#### TCP 三次握手发生在哪个函数之间

TCP 三次握手是发送在**客户端**调用 `connect()` 函数的时候，注意服务器响应 ack 跟 `accept()` 没什么关系，服务器在 listen() 之后，就可以响应 ack，所以如果问发生在服务器端的哪个函数，应该说是 `listen()` 之后。

# arp命令

#### 过程（这个比较重要）

ARP协议完成了ip与物理地址的映射，每台主机都会在自己的**ARP缓冲区中建立一个ARP列表**，以表示**ip和MAC之间的对应关系**。当源主机将一个数据包发送到目的主机时，首先会检查自己的ARP列表中是否存在该ip对应的MAC地址，如果没有就像**本地网段发起一个ARP请求的广播包**，**查询目的主机对应的MAC地址**。此ARP请求包中包含源主机ip地址、目的主机ip地址、硬件地址。**网络中所有主机收到这个ARP请求后，会检查数据包中的目的ip与自己ip是否一致，不相同就忽略**。相同的话，该主机首先将发送端的MAC地址和ip地址添加到自己的ARP列表中，如果ARP表中已存在该ip信息，则将其覆盖，**然后给源主机发送一个ARP响应数据包，告诉对方自己是它想要查询的MAC地址**；源主机收到这个ARP响应数据包后，将得到的目的主机的ip地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据传输。如果源主机一直没收到ARP响应数据包，则查询失败。 

#### 语法 

```
arp(选项)(参数)
```

#### 选项 

```
-a<主机>：显示arp缓冲区的所有条目；
-H<地址类型>：指定arp指令使用的地址类型；
-d<主机>：从arp缓冲区中删除指定主机的arp条目；
-D：使用指定接口的硬件地址；
-e：以Linux的显示风格显示arp缓冲区中的条目；
-i<接口>：指定要操作arp缓冲区的网络接口；
-s<主机><MAC地址>：设置指定的主机的IP地址与MAC地址的静态映射；
-n：以数字方式显示arp缓冲区中的条目；
-v：显示详细的arp缓冲区条目，包括缓冲区条目的统计信息；
-f<文件>：设置主机的IP地址与MAC地址的静态映射。
```

## 流量控制

 https://blog.csdn.net/guoweimelon/article/details/50878503 

滑动窗口协议和连续ARQ协议一般是结合来使用。

需要注意的是tcp不适用停止等待协议，停止等待协议就是发送完一个就停止等待对方ack，但是这里不适用这种方式，而是一次性发送多个分组，这就是连续ARQ协议。

#### 滑动窗口协议

 http://www.52im.net/thread-515-1-1.html 

#### 连续ARQ协议

接收方一般都是采用累积确认的方式。也就是说接收方不必对收到的分组逐个发送确认。而是在收到几个分组后，对按序到达的最后一个分组发送确认。如果收到了这个分组确认信息，则表示到这个分组为止的所有分组都已经正确接收到了。  

这里涉及到了一个回退N帧。

累积确认的优点是容易实现，即使确认丢失也不必重传。但缺点是，不能正确的向发送方反映出接收方已经正确收到的所以分组的信息。比如发送方发送了前5个分组，而中间的第3个分组丢失了，这时候接收方只能对前2个发出确认。而不知道后面3个分组的下落，因此只能把后面的3个分组都重传一次，这种机制叫Go-back-N（回退N），表示需要再退回来重传已发送过的N个分组。

## 拥塞控制

 https://www.cnblogs.com/kubidemanong/p/12048297.html 

**ssthresh** ：慢开始门限

MAX：阈值

cwnd：拥塞窗口

#### 慢开始

指数开始

#### 拥塞避免

线性增长

如果发生超时重传，也就是拥塞窗口达到了阈值，那么慢开始门限减半，然后拥塞窗口从慢开始开始，也就是从1，2，4...开始，这个区别于快重传，快重传慢开始门限也减半，但是拥塞窗口是从慢开始门限开始。

#### 快重传

快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待为其设置的重传计时器到期。 

快重传不是计算的，只是说3次你就能重传

#### 快恢复

快恢复才是快的， **ssthresh** 变成max的一半，然后拥塞窗口等于ssthresh ，即 N = ssthresh，N在一个一个增长 

#### 两种重传

这里说一下，之前一直弄混了，实际上有两种重传：

1. **超时重传**：一种是没有收到ack，也就是我们常说的cwnd达到max，那么采用的是先让ssthresh=cwnd的一半，**然后cwnd回到最初的状态，从1，2，4，8...这样开始**。
2. **快重传**，也就是连续收到了3次相同的ack，这个时候，也是先让ssthresh=cwnd的一半，但是之后不一样的来了，**然后让cwnd=ssthresh**。

#### 乘法减小

当遭遇一个拥塞, 将 ssthresh 设置为当前 cwnd 的一半 .

#### 加法增大

当 cwnd 大于 ssthresh 之后还没有遭遇拥塞, cwnd 的增长策略切换为 `拥塞避免`, 每经历一个传输轮次后 cwnd 加一个 MSS , 呈线性增长, 即 `加法增大` .

### 注意

流量控制对应的是滑动窗口协议，拥塞控制对应的是拥塞窗口cwnd，流量控制是发送方和接收方的事情，拥塞控制是发送方跟网络之间的事情。

两者针对的其实是不同的事情

## post和get的区别

 https://blog.fundebug.com/2019/02/22/compare-http-method-get-and-post/ 

##  tcp和udp的区别

**比较方向**

可靠性，是否有连接，报文格式，双工性，传输速度

![img](https://user-gold-cdn.xitu.io/2020/2/23/1706fe0aa460d91c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

##  TCP如何保证可靠性 

- 校验和，按16位为一个数据相加，最后的进位继续加，最终的值取反

   ![这里写图片描述](https://img-blog.csdn.net/20180524102010286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWNoZW54aWE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

  发送方：在发送数据之前计算检验和，并进行校验和的填充。
  接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。 

- 确认应答和序列号

- 超时重传

- 连接管理，三次握手，四次挥手

- 流量控制

- 拥塞控制

 https://blog.csdn.net/liuchenxia8/article/details/80428157 

## HTTP 1.0 和 HTTP 1.1 的主要区别是什么

#### 长连接 :

 **在`HTTP`/1.0中，默认使用的是短连接**，也就是说每次请求都要重新建立一次连接。`HTTP` 是基于`TCP`/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。**`HTTP` 1.1起，默认使用长连接** ,默认开启 Connection： keep-alive。 **`HTTP`/1.1的持续连接有非流水线方式和流水线方式** 。流水线方式是客户在收到`HTTP`的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。

#### 错误状态响应码

在`HTTP`1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

#### 缓存处理

在`HTTP`1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，`HTTP`1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

#### 带宽优化及网络连接的使用

HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，`HTTP`1.1则在请求头引入了 **range** 头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 

## http2.0和http1.1的区别

面试版：https://blog.csdn.net/N1314N/article/details/91312173 

 https://www.zhihu.com/question/34074946 

####  **多路复用 (Multiplexing)** ：

注意多路复用不单单是复用tcp，而且是并行简单来说， 就是在同一个TCP连接，同一时刻可以传输多个HTTP请求。

> 之前是同一个连接只能用一次， 如果开启了keep-alive，虽然可以用多次，但是同一时刻只能有一个HTTP请求

如果是 keep-alive 中第一个请求阻塞了，那么后面的请求都会阻塞，如果是多路复用，第一个请求阻塞了，后面的依然不会阻塞，所以多路复用和 keep-alive 不一样，但是两者都是对 tcp 的复用，都是在一个 tcp 请求中传输多个 http 请求。

多路复用： https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/14 

#### 最终答案

1. HTTP/2采用二进制格式而非文本格式
2. HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行（ 有两个非常重要的概念，分别是帧（frame）和流（stream）。 ）
3. 使用报头压缩，HTTP/2降低了开销
4. HTTP/2让服务器可以将响应主动“推送”到客户端缓存中 