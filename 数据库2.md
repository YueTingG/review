## 事务的 ACID 特性

原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。 

## 读写锁

漫画编程  https://posts.careerengine.us/p/5c50a7e82a04ea4e26e637c0 

共享锁（S锁）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。 

- 也叫做**读锁**：读锁是**共享**的，多个客户可以**同时读取同一个**资源，但**不允许其他客户修改**。

排他锁（X锁)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。 

- 也叫做**写锁**：写锁是排他的，**写锁会阻塞其他的写锁和读锁**。

#### 自动加锁

对于UPDATE、DELETE、INSERT语句，InnoDB会自动给涉及数据集加排他锁(X) MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁，在执行增、删、改操作前，会自动给涉及的表加写锁，这个过程并不需要用户干预。

拿MySql的InnoDB引擎来说，对于`insert`、`update`、`delete`等操作。会自动给涉及的数据加排他锁； 

## 乐观锁和悲观锁

漫画编程 https://mp.weixin.qq.com/s/TZy8iIGDL3gHPhVxTnJDeQ

https://developer.51cto.com/art/201904/595251.htm 

#### 概念不要混淆

需要注意的是，其实这俩只能说是一种**思想**或者说加锁的时候一种**策略**，而**读写锁是一种真真正正存在的技术**。

从概念上来讲，这俩跟我们通常说的锁根本就不是概念级别的东西，可以说讨论乐观锁和悲观锁，就是在讨论如何使用锁，或者说加锁的策略是什么了，但是绝对不是说这俩是一种锁，应该讲是一种加锁的思想。

并且乐观锁和悲观针对的是**修改**的方面。

## 悲观锁

#### 定义

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。 

对于传统的单条sql来说，可以说就是用了悲观锁，不管怎么样，我先上锁再说。

#### 实现

悲观锁的实现，往往依靠数据库提供的锁机制。在数据库中，悲观锁的流程如下：

- 在对记录进行修改前，先尝试为该记录加上排他锁(exclusive locking)。
- 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。
- 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
- 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。

## 乐观锁

#### 定义

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用**版本号机制**和**CAS算法实现**。 

#### 实现

cas 和 version/time（时间戳）

#### cas

采用cas算法，就是我写前后看看某个变量的是不是改变的状态如我预期的。

```sql
// 扣减库存问题，通过乐观锁可以实现如下：

//查询出商品库存信息，quantity = 3 
select quantity from items where id=1 
//修改商品库存为2 
update items set quantity=2 where id=1 and quantity = 3; 
```

我们先搞清楚 cas，我们用 golang 里面的类比：

1. 先对比它跟原来的是不是一样（这个时候还没尝试去修改）。
2. 如果跟原来一样，我们再去修改。

所以第一步中，要想知道它跟原来一不一样，我们要查出原来的值，这里我们需要提出一个问题？我们要查什么？也就是 select xxx from  id = 5，也就是 xxx 是什么？

注意，你一开始想要修改什么，我们的 xxx 就是什么，要明白，我们的乐观锁针对的是**丢失修改**的事务问题。像上面的代码中，我们要扣库存，**实际上就是修改库存**，所以我一开始的时候就要**查库存**。一句话：**你要修改什么**，**你查什么**。

然后把你查出来的字段，作为 update 时候的条件拼进去。

总结就是：**你要修改什么，你查什么，然后作为 update 语句的 where 拼接进去。**

#### ABA

上面的 cas 操作一定能解决问题吗？不是的，如果有这么一种场景，线程1读取了 A 值，然后还未尝试修改，接着线程2读取了 A 值，把它改成 B 值，接着又把它改回了 A，线程1这样去写 sql 做判断的时候，确实还是 A 值，但是这样并不能保证一定不会出问题。

#### version

```
//查询出商品信息，version = 1 
select version from items where id=1 
//修改商品库存为2 
update items set quantity=2,version = 3 where id=1 and version = 2; 
```

version 能解决 ABA 问题。

是多增加一个字段version（或者时间戳），写成功一次就++（就是要自增），然后别人如果同时写，慢的人会发现前后版本不一致（写前读一次这个字段，写后读一次这个字段）。

#### 存在的问题

cas无法解决aba问题，version解决了ABA问题，但是实际上，当写比较多的时候，数据是需要回滚的，或者讲让写失败，或者不断重试。

这样的不断回退数据，或者让写失败，就是不好的，所以要想办法降低乐观锁的粒度（上面说了，只是思想，讨论如何加锁，你的粒度不行，肯定是策略不行）

## 乐观锁和mvcc

我第一次看到version就想到mvcc，以为这俩会不会是同一个东西，后来才发现根本就不一样。

虽然好像这俩都没有加锁，但是实际上完全是不同的东西，乐观锁是什么？就是你先写数据，写完了再判断到底能不能提交这个修改。

而mvcc呢？本身人家就不止一条数据，真说乐观锁和mvcc一样的地方就是都有个version字段，然后都没用锁，但是mvcc用的是多条数据来达到读写分离的作用。

而乐观锁呢？读写都是同一条数据，而且都是先写了再说，然后后面判断一下判断/时间戳符不符合要求。

具体看： https://www.zhihu.com/question/27876575 

## 乐观锁和隔离等级和事务并发问题的理解

 https://juejin.im/post/5d634c816fb9a06af238808f 

首先，数据库是由于实现了隔离等级的中前3个等级（可串行化不谈），从而解决了事务并发问题中的3个（脏读，不可重复读，幻读）。

也就是讲，数据库其实本身就已经解决了并发问题中的3个问题。

而剩下的**丢失修改**就是依靠乐观锁和悲观锁解决的。

所以实际上乐观锁和悲观锁与其他表锁行级锁，或者读写锁面向的，解决的根本就不是同一个问题。

读写锁面向的是单条sql，和行级锁和表锁是讨论我到底锁了一行还是一张表的问题。

而乐观锁和悲观锁是解决丢失修改的问题，他一定是基于读写锁的（毕竟它用到了sql）。

## 事务隔离级别的实现（主要是读取已提交和可重复读）

读取已提交和可重复读 https://www.cnblogs.com/stevenczp/p/8018986.html 

 https://m.php.cn/article/453139.html 

当前事务和行记录id https://juejin.im/post/5eeafc15e51d4573fa7d5824 

#### 每条行后面的三个列

**DB_TRX_ID**, 6byte, 创建这条记录/最后一次更新这条记录的事务ID。

**DB_ROLL_PTR**, 7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里undo log）

**DB_ROW_ID**, 6byte，隐含的自增ID，如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引。

这三者构成了我们常说的mvcc的版本控制，虽然我们常以版本来举例，例如某一行有xx版本号，但是实际上根本没有这个字段，只记录了最后修改的事务id（这个id就可以理解成版本，因为id越大版本越后）

#### 读取已提交和可重读的写操作

都是加锁（以后细说）

#### read_view（行可见性）

创建的时候mysql里面还在活跃未提交的事务，每个事务有id（id的大小决定是事务创建的快慢，越大越晚创建，因为id自增）

read_view中有两个关键值 up_limit_id（当前未提交事务的最小版本号-1，在up_limit_id之前的事务都已经提交，在up_limit_id之后的事务可能提交，可能还没提交） 和 low_limit_id（当前系统尚未分配的下一个事务id，也就是目前已出现过的事务id的最大值+1。注意：**low_limit_id不是最大的活跃事务的id**。） 

其实从理解上就是一个事务数组，这个数组有顺序，有的创建早有的创建晚，但是有个特点，**都是还未提交的**（注意指的是创建read_view那一刻是未提交的，但是过了创建read_view那一刻之后，可能有些就已经提交了，时间是在继续的）

#### 如何理解DB_TRX_ID和up_limit_id

#### 读取已提交和可重读的读操作

两者从宏观上和逻辑上其实是一样的，其实就一个地方不一样，但是这个微小的地方不一样造就了这两者的不同。

**读操作的逻辑**

1. 如果DB_TRX_ID小于up_limit_id，表示该行最后修改已经有事务提过了，并且DELETE_BIT=0，则该行记录对当前事务是可见的。 

2. 如果DB_TRX_ID大于low_limit_id，表示该行最后的修改还没有提交，所以该行记录的当前值不可见。 

3. 如果up_limit_id< = DB_TRX_ID <= low_limit_id， 需要进一步检查read_view中是否含有DB_TRX_ID， 

   **DB_TRX_ID**  不在read_view里面， 此记录的最后一次修改在read_view创建之前，可见。

   **DB_TRX_ID**  在read_view里面，  此记录的最后一次修改在read_view创建时尚未保存 ，不可见。 需要用DB_ROLL_PTR查找undo log(此记录的上一次修改)，然后根据undo log的DB_TRX_ID再从头计算一次可见性 

#### 用MVCC这一种手段可以同时实现RR与RC隔离级别

它们的不同之处在于：

**RR**：read view是在**first touch read**时创建的，也就是执行事务中的第一条SELECT语句的瞬间，后续所有的SELECT都是复用这个read view，所以能保证每次读取的一致性（可重复读的语义）

**RC**：每次读取，都会创建一个新的read view。这样就能读取到其他事务已经COMMIT的内容。

所以对于InnoDB来说，RR虽然比RC隔离级别高，但是开销反而相对少。

## b+树索引

还是多看看 [MySQL技术内幕(InnoDB存储引擎)第2版](D:\下载\MySQL技术内幕(InnoDB存储引擎)第2版)

### 聚集索引

![](C:\Users\78478\Desktop\review\Snipaste_2020-07-27_12-15-31.png)

#### 非叶子结点

1. 存放关键字key，而且注意看，三个父节点对应三个子结点（b树是父结点n，子结点n+1个）。
2. 然后存放指向下一个结点的指针，这里他们的下一个结点刚好是叶子结点，所谓指向下一个结点的指针到底是什么，就是下一个数据页的页号（有的地方讲是下一个数据页的偏移量，反正差不多，就是指向下一个数据页）

#### 叶子结点

存放的是我是第几个数据页，然后我里面的数据是什么。

## redolog

具体看mysql技术内幕

#### 重做日志缓冲

事务执行的时候**<u>记录物理数据页面的修改信息</u>** （这句话就是一切），在事务提交前把它写入重做日志文件。

这里有3点：

1. 写入的时机其实并不是只有提交前，主要有3个时机：
   1. 事务提交时；
   2. 当log buffer有一半内存空间已经被占用时；
   3. log checkpoint时。
2. 这里的写入不是字面上理解这么简单的，如果记住redis的aof持久化就会记得，文件写入和文件同步是不一样的，为了保证文件系统真正写入到了文件，每次写入的时候都会去调用fsync函数去真正同步到文件，不然就只是在内核缓冲区保留着。
3. 资料中总是在强调，日志的写入**基本上**是一个顺序写入。

#### 重做日志文件

事务的持久性就是依靠重做日志来实现的，更具体来讲就是依靠重做日志的文件来实现的，缓冲区的记录写入到文件的那一刻起就完成了持久化，可以这么理解。

当数据库重启需要恢复数据的时候，会读取重做日志文件。

（这里可能会认为很奇怪，为什么需要这样的持久化，因为实际上mysql每次写入为了性能并不会真的每次都把数据写入到文件，更多的保存到mysql的缓冲区中，所以需要有另外一种持久化机制）

#### 具体内容

```
page(2,3), offset 32, value 1,2 #聚集索引
page(2,4), offset 64, value 2   #辅助索引
```

大概这样，具体的我资料也没查到，总之就是记录了物理页的修改信息，就是告诉你你要到某一页的哪个偏移量改哪里的值，改成什么。

所以哪怕你是新增也是这样，直接改值。

#### 总结，关键字

**重做日志缓冲区**记录**数据页**的**修改信息**，然后写入**重做日志文件**。

作用：用来恢复数据，**实现事务的持久化**。

## 加深一下redolog是修改页的物理信息这句话的理解

假如你插入某条行，例如

```
insert into t select 1,2；
```

其重做日志大致为：

```
page(2,3), offset 32, value 1,2 #聚集索引
page(2,4), offset 64, value 2   #辅助索引
```

可以看到，实际上插入在redo中就是一条修改，它告诉你去修改哪里的页，并且修改的值是多少。

所以哪怕这条修改执行多次也没事，是**幂等**的，永远都只会有一条数据生成。

但是如果现在就是一条sql的插入，也就是说保存到日志中中的是一条命令而不是实际上的页的修改，那么你执行多次，它会生成多条数据。

## undolog

实现事务的一致性

#### 作用

回滚，mvcc

#### 记录的内容

记录了行的修改，是逻辑日志

#### 分类

insert undo log记录了insert操作，mvcc不需要用它

update undo log记录了update和delete操作，**mvcc用的就是它**

#### 回滚的逻辑

回滚的逻辑不是把之前的所有修改的逻辑都取消了，你如果直接取消会影响到其他不需要回滚的事务。所以回滚实际上是逻辑上的。

当回滚时它执行的是先前相反的工作。对于每个INSERT，InnoDB存储引擎会完成一个DELETE；对于每个
DELETE，innoDB存储引擎会执行一个INSERT：对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE，将修改前的行放回去。

### 根据上面的分类，具体讲讲insert和update undo log的内容上的区别

#### insert undo log

图7一14显示了insertundo10g的格式，其中*表示对存储的字段进行了压缩，

1. insert undo log开始的前两个字节nex记录的是下一个undo log的位置，通过该next的字节可以知道一个undog所占的空间字节数。
2. 类似地，尾部的两个字节记录的是undolog的开始位置。
3. type_cmpl占用一个字节，记录的是undo的类型，对于insert undo log，该值总是为ll。
4. undono记录事务的ID，tableid记录undolog所对应的表对象。这两个值都是在压缩后保存的。
5. 接着的部分记录了所有主键的列和值。
6. 在进行rollback操作时，根据这些值可以定位到具体的记录，然后进行删除即可。

  <div style="float:left; ">     <img src="C:\Users\78478\Desktop\review\Snipaste_2020-07-28_01-08-45.png" width=350px > </div>  
<div style="float:left; margin-top:30px">     <img src="C:\Users\78478\Desktop\review\Snipaste_2020-07-28_01-08-21.png" width=450px> </div>  














我们回滚一个数据，只需要定位到这条数据然后删除即可，我不需要知道你原来存的是什么值，也不关心，所以我需要所有的主键，保证到我定位到行，注意7-14左边是n_unique_index，表示这些列都是主键。

由于insert不需要参与到mvcc中，所以也不需要有DATA_ROLL_PTR用来回滚到上一个记录。

#### update undo log

`update undo log`相对于之前介绍的`insert undo log`，记录的内容更多，所占用的空间也更大。next、start、undono、tableid与之前介绍的insertundolog部分相同。这里的typecmpl'由于updateundolog本身还有分类，故其可能的值如下：

- 12 TRX_UNDO_UPD_EXIST_REC更新non-delete-mark的记录
- 13 TRX_UNDO_UPD_DEL_REC将delete的记录标记为notdelete
- 14 TRX_UNDO_DEL_MARK_REC将记录标记为delete

接着的部分记录update_vector信息，update_vector表示update操作导致发生改变的列。每个修改的列信息都要记录的undo log中。对于不同的undolog类型，可能还需要记录对索引列所做的修改。

  <div style="float:left; ">     <img src="C:\Users\78478\Desktop\review\Snipaste_2020-07-28_01-28-24.png" width=300px > </div>  
  <div style="float:right; ">     <img src="C:\Users\78478\Desktop\review\Snipaste_2020-07-28_01-29-52.png" width=400px > </div>  


























update undo log记录里面就记录了要修改的值，注意 update vector，里面就是修改的值。逻辑大概是这样，定位到行，然后具体这行修改了什么，要记录具体的值。

回滚的时候通过DATA_ROLL_PTR，找到上一条行，update相反的结果即可。然后是mvcc，追寻到上个版本的行，通过DATA_ROLL_PTR找到之前的版本。

#### 总结

undo日志记录的是行的信息。

回滚，mvcc

在每一行中有`DATA_ROLL_PTR`字段，通过这个字段实现回滚和mvcc。

## redolog和undolog与持久性的关系

 https://juejin.im/post/5e0f491ce51d4540e30a9b45#h 

认识，应该讲需要对redo和undo有一个正确的认识，他们都存储了数据，但是他们的目的都不是数据库的持久化，**注意redo是事务的持久化**，**不是数据库的持久化**。怎么理解？

#### redo的持久化和数据库的持久化

redo的生命周期是多少？也就是说它什么时候就没用了，这就要从mysql数据更新说起，实际上mysql数据更新之后，是放在buffer里面的，也就是说事务结束之后，并不会马上落盘数据（什么时候落盘不清楚，总之不是事务结束马上落）。

这个时候如果断电了，buf中的数据就会丢失，所以我们需要从别的地方进行持久化，所以有了redo，所以redo严格来讲它就是个顶班的，**数据库的持久化还是实际上还是依赖 mysql 数据文件**。只不过 Mysql 的数据没有马上落盘，所以我们先把数据落盘到redo，万一断电，可以根据redo恢复。

所以redo什么时候可以干掉，当mysql的数据落盘的时候，redo就没用了，人家数据持久化都完了，你个顶班（备胎）的没用了，还谈个毛的持久化。

所以redo不是数据库的持久化，只是那些刚刚执行完还没落盘的事务的持久化。

#### undo与持久化

undo是用来持久化的吗？答案是否定的，undo最根本的作用就是在事务提交的时候提供一个可以“反悔”的机会。即我现在不想写入数据了，我要回滚数据。

也就是说，在用户想要回滚数据的时候，undo出场了，所以从回滚数据的角度上讲，当一个事务结束的时候，其实undo就没用了，可以删除了，因为事务已经结束了，事务结束代表什么？代表commit了，不能再回滚了。

以上都是从回滚的角度思考，从mvcc的角度思考，undo就不能说事务结束就没用，它还要提供隔离级别的非锁定读（快照读）。

所以undo本质上跟持久化就没有关系，它仅仅只是为回滚提供一个实现而已，一旦不需要回滚以及mvcc，它就可以over了。

## undo 实现事务原子性

#### 原子性

什么是原子性，我们要先回答这个问题！那就是要么都成功要么都失败。假如，现在有a，b，c三条sql，前两条成功了，后一条失败了，这个时候要怎么办？当然是不成功？不成功怎么办？难道就让 a，b 执行成功，c失败吗？

不是的，这个时候就要返回 mysql 原来的状态，所以需要**回滚**，所以原子性的本质就是需要一个提供回滚的机制。让某件事情失败的时候能够回到原来的状态。

#### 回滚保证了原子性

本质上 undo 的**回滚**功能保证了 mysql 事务的原子性。