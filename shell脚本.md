## 字符串

### 单引号

单引号字符串的限制：

- 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的
- 单引号字串中不能出现单引号（对单引号使用转义符后也不行）

### 双引号

```
your_name='qinjx'
str="Hello, I know your are \"$your_name\"! \n"
```

- 双引号里可以有变量
- 双引号里可以出现转义字符

### 字符串操作

#### 拼接字符串

直接使用变量嵌套在里面即可，不需要加号

```
your_name="qinjx"
greeting="hello, "$your_name" !"
greeting_1="hello, ${your_name} !"

echo $greeting $greeting_1
```

#### 查找子字符串

查找字符 **i** 或 **o** 的位置(哪个字母先出现就计算哪个)：

```
string="runoob is a great site"
echo `expr index "$string" io`  # 输出 4
```

**注意：** 以上脚本中 **`** 是反引号，而不是单引号 **'**，不要看错了哦。

## Shell 传递参数

我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：**$n**。**n** 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……

几个特殊字符用来处理参数：

| 参数处理 | 说明                                                         |
| :------- | :----------------------------------------------------------- |
| $#       | 传递到脚本的参数个数                                         |
| $*       | 以一个单字符串显示所有向脚本传递的参数。 如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。 |
| $$       | 脚本运行的当前进程ID号                                       |
| $!       | 后台运行的最后一个进程的ID号                                 |
| $@       | 与$*相同，但是使用时加引号，并在引号中返回每个参数。 如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。 |
| $-       | 显示Shell使用的当前选项，与[set命令](https://www.runoob.com/linux/linux-comm-set.html)功能相同。 |
| $?       | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |

## Shell 基本运算符

例如，两个数相加(**注意使用的是反引号 ` 而不是单引号 '**)：

### expr表达式的使用

#### 实例

```
#!/bin/bash

val=`expr 2 + 2`
echo "两数之和为 : $val"
```

执行脚本，输出结果如下所示：

```
两数之和为 : 4
```

两点注意：

- 表达式和运算符之间要有**空格**，例如 **2+2** 是不对的，必须写成 **2 + 2**，这与我们熟悉的大多数编程语言不一样。
- 完整的表达式要被 **``** 包含，注意这个字符不是常用的单引号，在 Esc 键下边，**反引号**。

### 算术运算符

#### 实例

```
val=`expr $a \* $b`
echo "a * b : $val"
```

**注意：**

- 乘号(*)前边必须加反斜杠(\)才能实现乘法运算；

#### 代码中的 [] 执行基本的算数运算，如：

```
#!/bin/bash

a=5
b=6

result=$[a+b] # 注意等号两边不能有空格
echo "result 为： $result"
```

结果为:

```
result 为： 11
```

总结：

适用shell的计算能力可以用**expr表达式**（但必须用**反引号**），另一种就是用**$[]**的方式（方括号里面就**无需再用$**了）

### 关系运算符

| 运算符 | 说明                                                  | 举例                       |
| :----- | :---------------------------------------------------- | :------------------------- |
| -eq    | 检测两个数是否相等，相等返回 true。                   | [ $a -eq $b ] 返回 false。 |
| -ne    | 检测两个数是否不相等，不相等返回 true。               | [ $a -ne $b ] 返回 true。  |
| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | [ $a -gt $b ] 返回 false。 |
| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | [ $a -lt $b ] 返回 true。  |
| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | [ $a -ge $b ] 返回 false。 |
| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | [ $a -le $b ] 返回 true。  |
| ==     | 相等。用于比较两个数字，相同则返回 true。             | [ $a == $b ] 返回 false。  |
| !=     | 不相等。用于比较两个数字，不相同则返回 true。         | [ $a != $b ] 返回 true。   |

 **注意：**

* 条件表达式要放在方括号之间，并且要有空格，例如: **[$a==$b]** 是错误的，必须写成 **[ $a == $b ]**，等于号与变量之间要有空格，方括号与变脸也要有空格。
* 这里的运算符只适用于数字，字符串在另外一个。==与-eq的作用一致，非等于也一样。



### 字符串运算符

下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：

| 运算符 | 说明                                         | 举例                     |
| :----- | :------------------------------------------- | :----------------------- |
| =      | 检测两个字符串是否相等，相等返回 true。      | [ $a = $b ] 返回 false。 |
| !=     | 检测两个字符串是否相等，不相等返回 true。    | [ $a != $b ] 返回 true。 |
| -z     | 检测字符串长度是否为0，为0返回 true。        | [ -z $a ] 返回 false。   |
| -n     | 检测字符串长度是否不为 0，不为 0 返回 true。 | [ -n "$a" ] 返回 true。  |
| $      | 检测字符串是否为空，不为空返回 true。        | [ $a ] 返回 true。       |

## 逻辑运算符

以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:

| 运算符 | 说明                                      | 举例                                       |
| :----- | :---------------------------------------- | :----------------------------------------- |
| &&     | 逻辑的 AND                                | [[ $a -lt 100 && $b -gt 100 ]] 返回 false  |
| \|\|   | 逻辑的 OR                                 | [[ $a -lt 100 \|\| $b -gt 100 ]] 返回 true |
| -a     | 与运算，两个表达式都为 true 才返回 true。 | [ $a -lt 20 -a $b -gt 100 ] 返回 false。   |
| -o     | 或运算，有一个表达式为 true 则返回 true。 | [ $a -lt 20 -o $b -gt 100 ] 返回 true。    |

**注意：**&&是需要**两个方括号**的，而-a只要一个方括号。



## 流程控制

### if

if 语句语法格式：

```
if [ $v1 判断符号 $v2 ]
then
    command1 
    command2
    ...
    commandN 
fi
```

经常和test符号合用

```
if test $v1 判断符号 $v2 
then
    command1 
    command2
    ...
    commandN 
fi
```

### if else

if else 语法格式：

```
if [ condition ]
then
    command1 
    command2
    ...
    commandN
else
    command
fi
```

### if else-if else

if else-if else 语法格式：

```
if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi
```

### for/while

自查吧，太多了

## Shell 函数

### 基本用法

linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。

shell中函数的定义格式如下：

```
[ function ] funname [()]

{

    action;

    [return int;]

}
```

说明：

- 1、可以带function fun_name() 定义，也可以直接fun_name() 定义,不带任何参数。
- 2、参数返回，**可以显示加：return** 返回，如果**不加**，**将以最后一条命令运行结果**，作为返回值。 return只能返回数字，0~255，通常只用来表示执行成功或者失败（不是处理结果）
- 3、函数**返回值**可以通过`$?`来获取，函数的**输出**可以通过``来获取（另外如果向获取函数处理的结果，可以通过定义shell变量来获取结果）

```shell
#! /bin/bash

function dome(){
	echo 2
	return 1
}
v1=$?
echo v1: $v1
v2=`demo`
echo v2: $v2
```

结果：

```
v1: 1
v2: 2
# 由此可见，v1获取的是返回值，v2获取的是标准输出
```

### 返回值/退出状态与布尔值的关系

```shell
#! /bin/bash

function demo0(){
	return 0
}

function demo1(){
	return 1
}

if demo0
then
	echo true
else
	echo false
fi

if demo1
then
	echo true
else
	echo false
fi
```

结果:

```
true
false
```

**分析:**

结果里，0反而代表了true，而1代表了false和我们以往的编程理念相反，其实这里是遵循了unix系统设计（不展开扯），总之一句话，**退出状态（返回值）为0，代表着成功，对应的布尔值为true**；**退出状态非0代表着失败，对应布尔值为false**。

## Shell 输入/输出重定向

### 格式

```
# 最常见
cmd > file.txt

# >> 代表追加的意思，即在原有文件的内容基础上加cmd的输出内容
cmd >> file.txt
```

### 重定向深入讲解

一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：

- 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。
- 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。
- 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。

默认情况下，command > file 将 stdout 重定向到 file，command < file 将stdin 重定向到 file。

如果希望 stderr 重定向到 file，可以这样写：

```
echo "hello" 1> file.txt
./test.sh 2> file.txt
```

**注意：**1必须和>紧贴，不能出现 1 > 的情况

#### stdout和stderr全部重定向

1. 使用 `2>&1`

   ```
   ./test.sh > file.txt 2>&1
   ```

   **注意：**同样`2>&1`必须紧贴，而且是放后面，几种标准输入/输出里面唯一放后面的

2. 使用 `&`

   ```
   ./test.sh &> file.txt
   ```

   **注意：**同样`&>`必须紧贴

### /dev/null 文件

如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：

```
$ command > /dev/null
```

#### 解释

**/dev/null**  ： 在类Unix系统中，/dev/null，或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF。
在程序员行话，尤其是Unix行话中，/dev/null 被称为**位桶(bit bucket)**或者**黑洞(black hole)**。空设备通常被用于丢弃不需要的输出流，或作为用于输入流的空文件。这些操作通常由重定向完成。
