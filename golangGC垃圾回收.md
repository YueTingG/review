---
typora-root-url: ./
---

## 三色标记法（这东西要背的）

#### 过程

1.  在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色；
2. 从灰色对象的集合中选择一个灰色对象并将其标记成黑色；
3. 将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；
4. 重复上述两个步骤直到对象图中不存在灰色对象；

## 插入写屏障

https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#%E5%B1%8F%E9%9A%9C%E6%8A%80%E6%9C%AF 以这个里面为准，但是这里面有的没有解释得很清楚。

https://mp.weixin.qq.com/s/G7id1bNt9QpAvLe7tmRAGw 里面有些地方值得商榷，但是可以看图来理解插入写屏障，例如最后混合写屏障扫描栈不需要 stw 这点值得怀疑。

#### 代码

```
添加下游对象(当前下游对象slot, 新下游对象ptr) {
  //1
  标记灰色(新下游对象ptr)
  
  //2
  当前下游对象slot = 新下游对象ptr  
}
```

#### 理解 slot = prt

注意怎么理解 `slot = ptr` ，一开始我也是理解错了，我们以下面的图中的对象 4 和 8 来解释，是不是 4 是 slot？ptr 是 8?错得离谱，你仔细看代码里面的中文 “**当前下游对象**”，slot 指的是 4 “**原本的下游对象**”，**4 原本的下游对象是 nil 和 7**，**这里是把 nil 换成了 ptr 也就是 8**。

下面两幅图，观察对象 8，对象 8 就是上面的 ptr，它是新对象

#### 栈与插入写屏障

要注意，**插入写屏障只在堆上面开启**，**栈上面不开启**，所以导致栈上面可能存在`黑->白`这种情况

![640](/640.jpg)

![](/641.jpg)

#### 缺点

栈上面因为操作频繁，所以在 1.7 版本 go 也没有在栈上面加入插入写屏障，所以在栈上面的操作总会有一些问题。

图中在栈上面新增对象 9，但是栈上面没有插入写屏障，所以对象 9 不变色，这里有两种方案

1. 给栈都加写屏障
2. re-scan

所以一开始 go 的官方都是采用 2 来搞定的。

#### 怎么理解栈中的非根对象，非根对象的引用误区

根对象我们都理解了，我们来理解一下不是根对象的情况，我们知道栈中的根对象指的是所有有变量引用的内存。

```go
func fn() {
    obj := &struct{}
}
```

我们由上可知，obj 所占的对象就是根对象。

```
func fn() {
    obj := &struct{}
    obj = &struct{}
}
```

我们可以发现，我们 new 了两次对象，第一次的对象在函数中的语句运行到第二句的时候，obj 引用的对象就变了，那么问题来了，第一次的对象去哪了？会立刻消失吗？其实不会，第一次 new 的对象就属于要被 gc 回收的部分，你有没有发现，**你在这个函数里面已经不能在引用第一次的 new 出来的对象了**。第一次 new 出来的对象，现在就成了我们所说的非根对象，你不可能能再次获取到它。

我们看下面的图，会发现对象 5 其实就是我们上面所说的情况，所以有时候，我们总会纳闷，如果对象 1 引用了对象 5，那么“xx屏障好像就失效了，所以xxx屏障有问题”，这种说法从一开始就不成立，因为对象 1 不可能能引用对象 5，对象 5 已经无法获取了。

![](/639.jpg)

## 删除写屏障

#### 代码

```
添加下游对象(当前下游对象slot， 新下游对象ptr) {
  //1
  if (当前下游对象slot是灰色 || 当前下游对象slot是白色) {
          标记灰色(当前下游对象slot) //slot为被删除对象， 标记为灰色
  }
  
  //2
  当前下游对象slot = 新下游对象ptr
}
```

#### 理解 slot = prt

同样的，要正确理解，`slot = ptr`，slot 不是上游对象，他跟 ptr 都是下游。

#### 过程

![](/642.jpg)

![](/643.jpg)

删除写屏障其实到没什么可以说的，帮助记忆就是，**插入**写屏障是**新对象染色**，**删除**写屏障是**老对象染色**，而后面的混合写屏障就是**都染色**，**而上游对象从来没有染色过**。

#### 缺点

删除写屏障好像会有一些冗余的操作，导致性能不好，其实如果排除冗余，删除写屏障已经不错了，但是有了冗余，所以最后才有混合写屏障。

## 混合写屏障

#### 代码

```
添加下游对象(当前下游对象slot, 新下游对象ptr) {
      //1
      标记灰色(当前下游对象slot) //只要当前下游对象被移走，就标记灰色
      
      //2
      标记灰色(新下游对象ptr)
          
      //3
      当前下游对象slot = 新下游对象ptr
}
```

#### 新对象

**将创建的所有新对象都标记成黑色**，注意这里是不管栈还是堆，新创建的对象都会标记成黑色

#### 不确定的地方

我们前面说过，插入写屏障是不会在栈上面开启的，但是混合写屏障是否在栈上面开启就目前不是很清楚，因为有的资料里说没有，有的资料没有明说，但是就我自己的理解，因为栈现在是 stop 的，所以哪怕在栈上面开启了写屏障，它的作用也不很明显，因为在 gc 一开始，对象的颜色就确定了，新增的又都是黑色，所以不存在不符合三色不变性的问题。

## go 现在 gc 的策略

#### 策略

现在的做法是 **STW** 扫描一次协程栈 + **混合写屏障** + **创建对象默认黑色** 

https://mp.weixin.qq.com/s/G7id1bNt9QpAvLe7tmRAGw

https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C

在栈上的对象，不存在一个栈的对象突然改变引用，引用了另一个栈上的对象，如果栈引用了另外一个栈上的对象，必然引发内存逃逸。

#### stw 扫描栈

现在 stop 扫描完之后，栈上面的对象就确定了，要么是黑色要么是白色，这样确定后，引用绝对不会出现黑色引用白色的情况，具体原因参照上面我写的，非根对象的误区，你是非根对象，你就无法获取到它。