## Redis 复制过程大概

 https://juejin.im/post/5d88d854518825090f41990c#heading-4 

Redis 的复制功能分为**同步**( sync )和**命令传播**( command propagate )两个步骤：

- 同步用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。
- 命令传播则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。

**同步又分完整重同步和部分重同步**。

#### 同步的区别

完整重同步一般用于初次复制，也有可能用于断线重连的情况，只能说一般。

部分重同步一般用于断线重连。

## 同步

#### 同步的分类

完整重同步和部分重同步

#### 完整重同步

客户端向从服务器SLAVEOF命令，当前服务器成为某一台主服务器的从服务器，这其实就是在要求从服务器复制主服务器。

同步的步骤：

1. 从服务器向主服务器发送psync ? -1命令，这里我们只讨论新版，新版用psync代替sync，psync可能执行完整重同步或者部分重同步。
2. 主服务器收到psync命令之后，执行bgsave命令，在后台生成rdb文件，并使用一个缓冲区记录从现在开始的所有写命令。
3. 主服务器把rdb文件发送给从服务器，从服务器加载这个rdb文件。
4. 主服务器把缓冲区中的命令发送给从服务器，从服务器执行这些命令。（这个不是命令传播）

#### 命令执行

客户端向从服务器发送SLAVEOF命令，从服务器向主服务器发送sync命令。

#### 命令传播

主服务器会将自己执行的命令发送给从服务器执行。

#### 不要有偏见的认为psync就代表部分重同步

psync代替的是原来的sync，它既能执行部分重同步，也能执行完整冲同步。

## 部分重同步

#### 命令

从服务器向主服务器发送psync命令

#### 复制偏移量

主从双方都会维护一个复制偏移量。

主服务器发送N个字节，复制偏移量就会加上N。

从服务器收到N个字节，复制偏移量就会加上N。

#### 说明积压缓冲区之间，我们先思考一个问题

如果我从服务器断线了，重连之后，从服务器向主服务器发送psync，并且说明自己现在复制偏移量，那么到底主服务器是执行完整重同步还是部分重同步。

这里需要改正一个误区，重连的话并不说你执行psync就执行部分重同步，而是要根据复制积压缓冲区来进行判断的。下面就说明挤压缓冲区。

#### 复制积压缓冲区

复制积压缓冲区是一个固定1MB的队列，进行命令传播的时候不仅会发送给从服务器，也会写入积压缓冲区。

积压缓冲区中也存储了复制偏移量，所以根据从服务器发送过来的偏移量，如果偏移量还存在于积压缓冲区中，则执行部分重同步，否则执行完整重同步。

**如果执行部分重同步 ，主服务器会把积压缓冲区中从服务器偏移量后的数据发送给从服务器。**

#### 服务器运行ID

如果从服务器中的主服务器id和现在主服务器id一致，因为从服务器断线过，说不定断线之后主服务器变了，如果id一致，那么可以执行部分重同步，否则要执行完整重同步。

#### 现在来仔细想想部分重同步的实现

**实际上，部分重同步的实现就是在复制积压缓冲区里面，反正命令存储在积压缓冲区里面，最后其实就是把里面的数据发送给从服务器**。

其他什么偏移量啊，id啊，等等其实都是过滤条件，用来判断到底能否执行部分重同步，以及定位发送数据的位置

## 主从复制大的范围上讲

具体内容：[主从复制原理]( https://juejin.im/post/5d80ac83e51d45620821cf87#heading-2)

主从复制跟数据库差不多，主库写，从库读，读写分离

主从复制的配置还是比较简单的，下面来了解下主从复制的实现原理

Redis的主从复制过程大体上分3个阶段：**建立连接**、**数据同步**、**命令传播**

1. 建立连接， slaveof ，创建套接字

2. 全量复制和部分复制

   -  有两种情况下是完整重同步，一是slave连接上master第一次复制的时候；二是如果当主从断线，重新连接复制的时候有可能是完整重同步 
   -  部分重同步是用于处理断线后重复制的情况 

3. 命令传播

   当完成数据同步之后，主从服务器的数据暂时达到一致状态，当主服务器执行了客户端的写命令之后，主从的数据便不再一致。为了能够使主从服务器的数据保持一致性，主服务器会对从服务器执行命令传播操作，即每执行一个写命令就会向从服务器发送同样的写命令。

## 哨兵模式启动的步骤

首先肯定是用户发送一个命令，`redis-sentinel /conf/xxx.conf` 或者`redis-server /conf/xxx.conf --sentinel`，然后就开始启动哨兵模式

1. 初始化 sentinel 服务器，其实 sentinel 就是普通的 redis 服务器，只不过某些 redis 命令 sentinel 不使用而已。
2. 



 https://juejin.im/post/5b7d226a6fb9a01a1e01ff64#heading-27 

这个参考得多一点 https://www.jianshu.com/p/639e61c8f49e 

#### 3个命令

| 命令    | 作 用                                                        |
| ------- | ------------------------------------------------------------ |
| PING    | `Sentinel` 向 `Redis` 节点发送 `PING` 命令，检查节点的状态   |
| INFO    | `Sentinel` 向 `Redis` 节点发送 `INFO` 命令，获取它的 **从节点信息** |
| PUBLISH | `Sentinel` 向其监控的 `Redis` 节点 `__sentinel__:hello` 这个 `channel` 发布 **自己的信息** 及 **主节点** 相关的配置 |

#### 3个命令对应3个任务

1.  在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 [INFO [section\]](http://redisdoc.com/client_and_server/info.html#info) 命令。 当一个主服务器被 Sentinel 标记为客观下线时， Sentinel 向下线主服务器的所有从服务器发送 [INFO [section\]](http://redisdoc.com/client_and_server/info.html#info) 命令的频率会从 10 秒一次改为每秒一次。 <u>（通过  **info**  命令可以在只知道master的情况下了解slave，所以一开始的配置只有master，这里的用词也是“已知的所有服务器和从服务器”，代表一开始从服务器是未知的）</u>
2.  每隔2秒，向master节点的  `__sentinel__:hello`   频道上  **publish**  该sentinel节点**对于主节点的判断**以及**当前sentinel节点的信息**，同时**每个sentinel节点也会订阅该频道**，来了解其他sentinel节点以及它们对主节点的判断。 所以这个定时任务可以完成以下两个工作：<u>（通过publish来了解其他sentinel结点，也就是面试题中的，sentinel是如何发现其他哨兵的，答案就在这里，就是某一个哨兵往频道上发送消息，其他哨兵订阅这个频道）</u>

    -  **sentinel节点之间互相发现**，每个sentinel节点上只配置了redis master节点，  通过这种方式，sentinel节点之间就可以实现互相发现。来实现后续的sentinel节点之间的互相通信、选举操作

    -  sentinel节点之间交换主节点状态，作为后面客观下线以及领导者选举的依据。
3.  每隔1秒，会向master、slave节点、其余sentinel节点发送  **ping**  命令做一次心跳检测，来确认这些节点当前是否可达。sentinel就是基于这个ping命令来决定redis节点和sentinel节点是否活着。<u>（心跳检查）</u>

#### info（sentinel发现从，建立命令和订阅）

1. 发给谁：**主从服务器**（不确定是否发给sentinel），并且不发给`_sentinel_:hello`，解决一个问题，为什么能够给从服务器发，一开始都没有从服务器，你怎么发给从的？

2. 如何发给从：先发给**主服务器**，获取到**从服务器**的信息，然后重点来了，和**从服务器之间建立命令连接和订阅连接**，这个为什么能发给从服务器？实际上有两重含义，第一个你要发现从服务器，第二个你要具备给从发命令的能力，指的就是建立命令连接。

3. 从这之后的发送目标：主从都发。

#### public（sentinel向别人发送消息）

1. 发给谁：主从，并且是发给`_sentinel_:hello`，**不需要发送给其他sentinel**，因为他们会订阅频道知道sentinel的存在。
2. 到底sentinel之间是如何发现的，新人发给`_sentinel_:hello`，老人监听`_sentinel_:hello`，所以就发现新人了，所以两方都要工作，**一方发，一方监听**。
3. 监听之后：sentinel之间只**建立命令连接**，不建立订阅

#### 主观下线和客观下线

<u>下线与否主要是通过  **ping**  命令来判断的</u>

1. 主观下线
   上面介绍的sentinel的第三个定时任务每秒对其他的节点  **ping**  一次，如果这个节点超过 `down-after-milliseconds` 没有有效的回复，该sentinel节点就会对这个节点做失败判定，这个行为是主观下线。由此可见主观下线只是单个sentinel的判定行为，在分布式环境中，肯定不能只靠一个节点的判断。
2. 客观下线
   当sentinel主观下线的节点是master时，该sentinel就会向其他sentinel节点发送sentinel is-master-down-by-addr命令询问对主节点的判断，当超过{quorum}个数sentinel节点认为主节点确实有问题，这时该sentinel会做出客观下线的决定。

#### sentinel leader选举

<u>先选sentinel的leader，而不是直接就选master</u>

sentinel做出客观下线的决定之后并不会立即进行故障转移，而是要在sentinel之间选举出一个leader，由leader来执行具体的故障转移工作。
 其实在上面的客观下线中，sentinel发送sentinel is-master-down-by-addr命令的时候就已经包含了leader选举的一些信息。
 sentinel is-master-down-by-addr {故障masterIP} {故障masterPort} {downState} {leader_runid}

-  **downState**：1是下线、0是在线
-  **leader_runid**：如果为*，表示返回结果只是用来表示主节点是否可达，当leader_runid等于具体的runid时，就代表目标节点同意runid称为leader

**选举规则**

（一句话，先到先得，sentinel1先到了3，之后sentinel2到了3已经没用了）

每一个Sentinel节点都可以成为Leader，当一个Sentinel节点确认redis集群的主节点主观下线后，会请求其他Sentinel节点要求将自己选举为Leader。被请求的Sentinel节点如果没有同意过其他Sentinel节点的选举请求，则同意该请求(选举票数+1)，否则不同意。

如果一个Sentinel节点获得的选举票数达到Leader最低票数(quorum和Sentinel节点数/2+1的最大值)，则该Sentinel节点选举为Leader；否则重新进行选举。
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190202175541832.png) 

这个规则中没有关于纪元得描述，只是一个简化版，更详细的看： [选举领头Sentinel的规则和方法](https://zhuanlan.zhihu.com/p/60632927)

#### Sentinel Leader决定新主节点

当Sentinel集群选举出Sentinel Leader后，由Sentinel Leader从redis从节点中选择一个redis节点作为主节点：

1. 过滤故障的节点（这个争议很大，各说各话：[选举新服务器]( https://zhuanlan.zhihu.com/p/60632927 )，[slave选举与优先级]( https://www.cnblogs.com/knowledgesea/p/6567718.html )）
2. 选择优先级  **slave-priority**  最大的从节点作为主节点，如不存在则继续
3. 选择复制偏移量（数据写入量的字节，记录写了多少数据。主服务器会把偏移量同步给从服务器，当主从的偏移量一致，则数据是完全同步）最大的从节点作为主节点，如不存在则继续。（ 哪个从master接收的复制数据多 ）
4. 选择 **运行id**（redis每次启动的时候生成随机的runid作为redis的标识）最小的从节点作为主节点

## 还差分片集群模式

## 命令传播和命令追加

一个是复制的，一个是aof的