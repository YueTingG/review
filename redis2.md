# 复制

## 异步复制

这里我现在有点疑惑，但是官网讲得很清楚：redis 采用的是**异步复制**，怎么理解**同步**和**异步复制**之间的关系呢？

#### 异步复制与同步

官网是怎么描述异步复制的

>  主服务器不会每次都等待副本处理命令... Redis复制在主端无阻塞。这意味着当一个或多个副本执行初始同步或部分重新同步时，主服务器将继续处理查询 

所以理解上，其实异步复制讲得是复制的过程中 master 阻不阻塞的问题？而同步，也就是完整重同步和部分重同步描述的是复制多少的问题？也就是到底是从头开始复制，还是从我断开的地方开始复制。

同步的原理当中并未提到主服务器阻不阻塞，而实际上是不阻塞的，完整重同步就很明显，我主服务复制的过程都是 fork 一个进程来处理，当然主服务器不会阻塞。

而部分重同步呢？无论是我把积压缓冲区里面的数据给你，还是命令传播把命令给你，我主服务只负责给你，但是实际上 redis 的从服务器执行这些命令是需要时间的，如果现在主服务器等待了从服务器执行这些命令，那么就是同步复制，但是实际上，主服务器会立马返回，它压根就不关心你从服务器是否已经执行了，所以就这方面来讲，它是异步的。

所以异步的关键就是，**主服务器不会等待从服务器处理命令**就返回了。

## Redis 复制过程大概

 https://juejin.im/post/5d88d854518825090f41990c#heading-4 

#### 过程

Redis 的复制功能分为**同步**( sync )和**命令传播**( command propagate )两个步骤：

- 同步用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。
- 命令传播则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。

**同步又分完整重同步和部分重同步**。

#### 同步的区别

完整重同步一般用于初次复制，也有可能用于断线重连的情况，只能说一般。

部分重同步一般用于断线重连。

## 同步

#### 同步的分类

完整重同步和部分重同步

#### 完整重同步

```sh
// 从服务器成为某个主服务器的从的命令
SLAVEOF host port

redis 127.0.0.1:6379> SLAVEOF 127.0.0.1 6379
OK
```

客户端向从服务器 `SLAVEOF` 命令，当前服务器成为某一台主服务器的从服务器，这其实就是在要求从服务器复制主服务器。

同步的步骤：

1. 从服务器向主服务器发送 `psync ? -1` 命令，这里我们只讨论新版，新版用 `psync` 代替 sync，psync 可能执行完整重同步或者部分重同步。
2. 主服务器收到 `psync` 命令之后，执行 `bgsave` 命令，在后台生成 `rdb` 文件，并使用一个缓冲区记录从现在开始的所有写命令。
3. 主服务器把 `rdb` 文件发送给从服务器，从服务器加载这个 `rdb` 文件。
4. 主服务器把缓冲区中的命令发送给从服务器，从服务器执行这些命令。（**这个不是命令传播**）

#### 命令执行

客户端向从服务器发送 SLAVEOF 命令，从服务器向主服务器发送 sync 命令。

#### 命令传播

主服务器会将自己执行的命令发送给从服务器执行。

#### 不要片面的认为 `psync` 就代表部分重同步

`psync` 代替的是原来的 `sync`，它既能执行部分重同步，也能执行完整冲同步。

## 部分重同步

#### 命令

从服务器向主服务器发送psync命令

#### 复制偏移量

主从双方都会维护一个复制偏移量。

主服务器发送N个字节，复制偏移量就会加上N。

从服务器收到N个字节，复制偏移量就会加上N。

#### 说明积压缓冲区之前，我们先思考一个问题

如果我从服务器断线了，重连之后，从服务器向主服务器发送 `psync`，并且说明自己现在复制偏移量，那么到底主服务器是执行完整重同步还是部分重同步？

这里需要改正一个误区，重连的话并不说你执行 `psync` 就执行部分重同步，而是要根据复制积压缓冲区来进行判断的。下面就说明挤压缓冲区。

#### 复制积压缓冲区

复制积压缓冲区是一个固定1MB的队列，进行**命令传播**的时候不仅会发送给从服务器，也会写入积压缓冲区。

积压缓冲区中也存储了复制偏移量，所以根据从服务器发送过来的偏移量，如果偏移量还存在于积压缓冲区中，则执行部分重同步，否则执行完整重同步。

**如果执行部分重同步 ，主服务器会把积压缓冲区中从服务器偏移量后的数据发送给从服务器。**

#### 服务器运行ID

如果从服务器中的主服务器 id 和现在主服务器 id 一致，因为从服务器断线过，说不定断线之后主服务器变了，如果 id 一致，那么可以执行部分重同步，否则要执行完整重同步。

#### 现在来仔细想想部分重同步的实现

**实际上，部分重同步的实现就是在复制积压缓冲区里面，反正命令存储在积压缓冲区里面，最后其实就是把里面的数据发送给从服务器**。

其他什么偏移量啊，id啊，等等其实都是过滤条件，用来判断到底能否执行部分重同步，以及定位发送数据的位置

## 主从复制大的范围上讲

具体内容：[主从复制原理]( https://juejin.im/post/5d80ac83e51d45620821cf87#heading-2)

主从复制跟数据库差不多，主库写，从库读，读写分离

主从复制的配置还是比较简单的，下面来了解下主从复制的实现原理

Redis的主从复制过程大体上分3个阶段：**建立连接**、**数据同步**、**命令传播**

1. 建立连接， slaveof ，创建套接字

2. 全量复制和部分复制

   -  有两种情况下是完整重同步，一是slave连接上master第一次复制的时候；二是如果当主从断线，重新连接复制的时候有可能是完整重同步 
   -  部分重同步是用于处理断线后重复制的情况 

3. 命令传播

   当完成数据同步之后，主从服务器的数据暂时达到一致状态，当主服务器执行了客户端的写命令之后，主从的数据便不再一致。为了能够使主从服务器的数据保持一致性，主服务器会对从服务器执行命令传播操作，即每执行一个写命令就会向从服务器发送同样的写命令。

# 哨兵

## 哨兵的史诗级 INFO、PUBLISH、PING 命令总结

*这些命令都是哨兵发送的*，更具体这些命令干了啥就看下面，但是面试的话建议看这里，不然你怎么跟面试官解释一堆东西？

#### INFO

10 秒一次向主服务器，从服务器发送 info 命令，获取他们的信息。

（有没有向 sentinel 发送就未知）

#### PUBLISH

2 秒一次向主服务器和从服务器发送 PUBLISH 命令，告知他们哨兵的自己信息。

#### PING

1 秒一次，心跳检测，用于判断是否下线。

## 哨兵模式

#### sentinel 的添加

首先肯定是用户发送一个命令，`redis-sentinel /conf/xxx.conf` 或者`redis-server /conf/xxx.conf --sentinel`，然后就开始启动哨兵模式，步骤：

1. 初始化 sentinel（记不住的，所以就记住初始化就行了），具体看书（实际上光这里就有3点）
2. 根据配置文件，初始化 sentinel 要监视的服务器列表（注意不是初始化主服务器，并没有添加任何主服务器）。
3. 创建连向主服务器的网络连接（实际上就是命令连接和订阅连接）。

**注意**：redis-sentinel **只是用来初始化一个 sentinel**，说白了就是用来添加 sentinel 的，并不能添加master，因为 master 本来就有了，这里只是跟 sentinel 说你要监视谁而已。

#### 获取主服务器信息

sentinel 默认会以**每十秒一次**的频率发送 INFO 命令，INFO 命令返回主服务器的信息，以及其从服务器对应的信息，<u>所以 sentinel 模式无须用户提供从服务器信息</u>。

#### 获取从服务器信息

实际上在上面的 **“获取主服务器信息”** 中已经是获取了一部分从服务器信息了，就是端口和 ip ，但是可以理解为只是部分信息，不全，书上用了 **"发现“**这个字眼，就是通过获取主服务器的信息顺便**”发现从服务器“**。

在知道从服务器的端口和 ip 之后，sentinel 会与从服务器建立命令连接和订阅连接。

然后也会每十秒发送一次 INFO 命令，这一次获取到的信息就比较全，可以说是真正的获取从服务器的信息，但是论发现，还是得说是通过发送 INFO 给主服务器发现的。

#### 向主服务器和从服务器发送信息

sentinel 会以**两秒一次**的频率，通过**命令连接**，发送 **PUBLISH** 命令，往 `_sentinel_:hello` 频道向 **主服务器** 和 **从服务器**发送消息。

消息内容：sentinel 自己的信息（ip，port，name等），以及主服务器的信息。（具体消息格式看书）

#### 接收来自主服务器和从服务器的频道信息

当 sentinel 与一个主服务器或者从服务器建立订阅连接之后，就可以对`_sentinel_:hello`频道进行订阅，所有订阅了该频道的 sentinel 都可以接收到消息。

上面提到的 PUBLISH 就可以通过该频道接收到消息。

#### PUBLISH与`_sentinel_:hello`

sentinel 会以**两秒一次**的频率往 `_sentinel_:hello` 频道，发送 **PUBLISH** 命令。

一个 sentinel  通过命令连接往 `_sentinel_:hello` 频道接收消息，而其他 sentinel 通过 `_sentinel_:hello` 订阅接收该 sentinel 发送的消息。

#### sentinel的发现与创建命令连接

PUBLISH 会发送 sentinel 自己的消息，如果是第一次发送，已有 sentinel 就发现新的 sentinel 的存在，接着创建连向新的 sentinel 的**命令连接**。

不需要订阅连接，因为他们都通过主服务器的订阅连接通讯，所以 sentinel 之间不再需要额外的订阅连接。

## 哨兵的下线

记住两个关键参数即可，**down-after-millseconds** 和 **quorum**。

#### 主观下线

默认 sentinel 会一秒一次向其他主服务器，从服务器，sentinel 发送 **PING** 命令。如果实例在 `down-after-millseconds` 内没有回复，就进入主观下线。

#### 客观下线

当 sentinel 判断主服务器客观下线之后，他会向其他 sentinel 进行询问，询问的方式是发送 `sentinel is-master-down-by-addr`。

如果超过 `quorum` 个 sentinel 判断下线，那么主服务器进入客观下线。

## 领头羊选举（这个到时候看看能不能补）

主要是内容太多了，记不住

## 故障转移

#### 步骤

实际上，第一步应该是挑选领头羊

1. 从从服务器中挑选主服务器。
2. 把其他从服务器改为复制新的主服务器。
3. 把下线的主服务器设置成从服务器。

#### 挑选主服务器

挑选规则：太多了，记不住的，所以简略知道

1. 断线的，下线的不要。
2. 最近5秒没回领头羊的不要。
3. 与主服务器断线时间超过 `10*down-after-milliseconds` 不要，因为越早断线，说明你的数据越老，越不准。
4. 前面3点主要是过滤，剩下的按照优先级进行排序，选优先级最高得
5. 优先级一样，选复制偏移量最大。
6. 都不满足，挑运行 id 最小的。

挑选完成之后，领头羊需要**每秒1次**发送 **INFO** 命令给新的主服务器，主要是要观察 **role** 字段是否**从原来的 slave 变成 master**。

## sentinel leader选举（暂时看这个版本）

<u>先选sentinel的leader，而不是直接就选master</u>

sentinel做出客观下线的决定之后并不会立即进行故障转移，而是要在sentinel之间选举出一个leader，由leader来执行具体的故障转移工作。
 其实在上面的客观下线中，sentinel发送sentinel is-master-down-by-addr命令的时候就已经包含了leader选举的一些信息。
 sentinel is-master-down-by-addr {故障masterIP} {故障masterPort} {downState} {leader_runid}

-  **downState**：1是下线、0是在线
-  **leader_runid**：如果为*，表示返回结果只是用来表示主节点是否可达，当leader_runid等于具体的runid时，就代表目标节点同意runid称为leader

**选举规则**

（一句话，先到先得，sentinel1先到了3，之后sentinel2到了3已经没用了）

每一个Sentinel节点都可以成为Leader，当一个Sentinel节点确认redis集群的主节点主观下线后，会请求其他Sentinel节点要求将自己选举为Leader。被请求的Sentinel节点如果没有同意过其他Sentinel节点的选举请求，则同意该请求(选举票数+1)，否则不同意。

如果一个Sentinel节点获得的选举票数达到Leader最低票数(quorum和Sentinel节点数/2+1的最大值)，则该Sentinel节点选举为Leader；否则重新进行选举。
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190202175541832.png) 

这个规则中没有关于纪元得描述，只是一个简化版，更详细的看： [选举领头Sentinel的规则和方法](https://zhuanlan.zhihu.com/p/60632927)

#### Sentinel Leader决定新主节点

当Sentinel集群选举出Sentinel Leader后，由Sentinel Leader从redis从节点中选择一个redis节点作为主节点：

1. 过滤故障的节点（这个争议很大，各说各话：[选举新服务器]( https://zhuanlan.zhihu.com/p/60632927 )，[slave选举与优先级]( https://www.cnblogs.com/knowledgesea/p/6567718.html )）
2. 选择优先级  **slave-priority**  最大的从节点作为主节点，如不存在则继续
3. 选择复制偏移量（数据写入量的字节，记录写了多少数据。主服务器会把偏移量同步给从服务器，当主从的偏移量一致，则数据是完全同步）最大的从节点作为主节点，如不存在则继续。（ 哪个从master接收的复制数据多 ）
4. 选择 **运行id**（redis每次启动的时候生成随机的runid作为redis的标识）最小的从节点作为主节点

# 分片集群

## 史诗级总结（比较烂，待完善）

#### 分片

对数据进行分片，每台结点负责 0-16383 当中的一个区间。相当于集群把 0-16383 划分区间，让每个结点只负责一部分区间，达到让数据分片的目的。

#### key 的定位

crc16 对 key 进行 hash 计算，然后对 16384 进行取余，得到一个 0-16383 的值。

## 数据分区原理

#### 虚拟槽分区算法

会把redis集群**分成** 16384 个槽（**0 -16383**），然后**指派**给对应的节点，例如把 0 -16383 范围的槽可能分成三部分（0-5000）、（5001-11000）、（11001-16383）分别数据三个缓存节点的槽范围。 

当客户端请求过来，会首先通过对key进行 **CRC16** 校验并对 **16384 取模**（**CRC16(key)%16383**）计算出 key 所在的槽，然后**根据槽转到对应的节点**的数据库上进行对应的操作。 

#### 所谓的槽

所谓的槽就是每个节点上面都会有一个**二进制数组**，在 `clusterNode` 中有一个 slots 字段，就是一个 char 数组（理解上可以理解成二进制数组），一共 **16384** 长度，当二进制位为 1 的时候，就代表这个槽是由当前节点负责。

#### 槽的指派

```
127.0.0.1:7000 > clutser addslots 0 1 2 ... 5000
```

上述命令会把 0~5000 指派给 7000 节点，**只有所有的槽指派完毕**，集群才算**上线**，如果只是集群有节点而没有指派槽，不算上线。

**注意**：被指派的槽不能是**已分配**的槽，所以实际上这条命令就是用来在初始化的时候使用。

#### 启动 cluster

配置 `clutser-enabled` 为 yes 开启集群模式

## 节点加入

#### 节点的加入

使用 cluster-meet ip port 命令，就可以让一个现有的节点，加入一个集群

```
127.0.0.1:7000 > cluster meet 127.0.0.1 7001
```

上述的命令就会把 7001 加入到 7000 的节点（注意谁加入谁）

#### cluster-meet 实现

cluster-meet 命令过程如下：

![](C:\Users\78478\Desktop\review\Snipaste_2020-09-08_17-36-07.png)

## 重新分片/槽的迁移

#### 重新分片的命令

```sh
redis-cli -a cc --cluster reshard 192.168.163.132:6379
```

6379 是源，待会下面会让你**输入要重新分片的槽的个数**，以及**目标节点的 id**（迁到哪）。

说得更具体得就是从 6379 移动到 x（你输入得）。

#### 具体的子命令

```sh
# 对源节点设置成迁移MIGRATING
CLUSTER SETSLOT MIGRATING destination-node-id

# 对目标节点设置成导入IMPORTING
CLUSTER SETSLOT <slot> IMPORTING <source-node-id>
```

#### ASK 错误

如果请求打到 6379，但是现在 key 迁移到 x 上面，那么就会返回一个 ASK，然后引导客户端去找 x。

#### addslots 和 setslot

实际上，如果是要在一个已经运行的集群中加入新的节点，并开始运用，包括重新分片，要使用 setslot，而不是 addslots，addslots 只能用在未分配的槽。

## 数据请求

#### 判断槽的位置

redis 的 `clutserState` （上面那个是 `clusterNode`）维护了一个 slots字段，里面是 `clusterNode` 数组，长度为 **16384**，每个位置上记录槽处理该槽的节点，也就是每个索引位置上有 ip 和 端口等信息。

![](C:\Users\78478\Desktop\review\Snipaste_2020-09-09_17-17-14.png)

#### 执行命令

当集群执行命令的时候，节点用 `CRC16(KEY)&16383` 计算出 key 对应的槽之后，会去读取 **clusterState.slotes** 这个 `clusterNode` 数组，判断是不是当前节点处理该槽，如果不是，clusterNode 中记录了处理该槽的节点的 ip 和端口，把命令转到那个节点过去。

## 集群模式的复制

首先，实际上集群模式所采用的复制，包括什么完整重同步和部分重同步都是和主从复制一摸一样的，唯一不一样的就是采用的命令。

主从复制采用的命令是 slaveof ip port，而集群模式的复制采用的是 `cluster replicate node_id`，这个命令最后其实也会去执行 slaveof ip port。

这个注意一下就可以了，其他的都是一样的。

## 下线

关键：PING 命令，**NODE_TIMEOUT**，**半数以上**。

#### 故障检测

每个节点都会定期向其他节点发送 PING 命令，其他节点需要恢复 PONG 命令，线下的判断基于 PING 命令。

#### 疑似下线 PFAIL

在  **NODE_TIMEOUT** 时间内没有回复则会被标记为疑似下线 （probable fail，PFAIL）。

#### FAIL

超过**半数以上**的主节点认为下线，则该节点为已下线 FAIL。

判断下线的节点会广播一个 FAIL 命令，通知其他节点该节点已下线。

## 故障转移

#### 过程

数里面的过程比较多，但是还是那句话具体的看书，要记还是记简单点

1. 挑选新的主节点。
2. 把槽指派给自己（原来的主节点的槽）。
3. **广播一条 PONG 命令**。

#### 挑选主节点

跟 sentinel 的**选举领头羊的模式差不多**，最后票数超过一半的节点成为主节点。

关键词：**纪元**，**先到先得**，**每个纪元一次投票机会**。

## 重定向

#### 两个

一个是 MOVED ，一个 ASK。

#### MOVED

MOVED 发生的情况是，我客户端的要操作的 key 不在现在的节点上（集群内有很多节点，但我们都是操作其中一个节点），所以发生一个 MOVED 重定向，跳转到 key 对应的槽的节点上面。

#### ASK

发生在数据迁移上面，也就是讲原本数据 key 确实在 A 节点，但是现在重新分片，key 在节点 B 上面，所以发生一个 ASK 重定向。

## 扩容

这里运用上面的知识做一下概括

#### 新加节点

MEET 命令

#### 重新分片

使用 `--cluster reshare` 或者 `cluster setslot` 命令。不是 `cluster addslots`。