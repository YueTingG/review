## Redis 复制过程大概

 https://juejin.im/post/5d88d854518825090f41990c#heading-4 

Redis 的复制功能分为**同步**( sync )和**命令传播**( command propagate )两个步骤：

- 同步用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。
- 命令传播则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。

**同步又分完整重同步和部分重同步**。

#### 同步的区别

完整重同步一般用于初次复制，也有可能用于断线重连的情况，只能说一般。

部分重同步一般用于断线重连。

## 同步

#### 同步的分类

完整重同步和部分重同步

#### 完整重同步

客户端向从服务器 `SLAVEOF` 命令，当前服务器成为某一台主服务器的从服务器，这其实就是在要求从服务器复制主服务器。

同步的步骤：

1. 从服务器向主服务器发送 `psync ? -1` 命令，这里我们只讨论新版，新版用 `psync` 代替 sync，psync 可能执行完整重同步或者部分重同步。
2. 主服务器收到 `psync` 命令之后，执行 `bgsave` 命令，在后台生成 `rdb` 文件，并使用一个缓冲区记录从现在开始的所有写命令。
3. 主服务器把 `rdb` 文件发送给从服务器，从服务器加载这个 `rdb` 文件。
4. 主服务器把缓冲区中的命令发送给从服务器，从服务器执行这些命令。（这个不是命令传播）

#### 命令执行

客户端向从服务器发送SLAVEOF命令，从服务器向主服务器发送sync命令。

#### 命令传播

主服务器会将自己执行的命令发送给从服务器执行。

#### 不要片面的认为 `psync` 就代表部分重同步

`psync` 代替的是原来的 `sync`，它既能执行部分重同步，也能执行完整冲同步。

## 部分重同步

#### 命令

从服务器向主服务器发送psync命令

#### 复制偏移量

主从双方都会维护一个复制偏移量。

主服务器发送N个字节，复制偏移量就会加上N。

从服务器收到N个字节，复制偏移量就会加上N。

#### 说明积压缓冲区之前，我们先思考一个问题

如果我从服务器断线了，重连之后，从服务器向主服务器发送 `psync`，并且说明自己现在复制偏移量，那么到底主服务器是执行完整重同步还是部分重同步？

这里需要改正一个误区，重连的话并不说你执行 `psync` 就执行部分重同步，而是要根据复制积压缓冲区来进行判断的。下面就说明挤压缓冲区。

#### 复制积压缓冲区

复制积压缓冲区是一个固定1MB的队列，进行命令传播的时候不仅会发送给从服务器，也会写入积压缓冲区。

积压缓冲区中也存储了复制偏移量，所以根据从服务器发送过来的偏移量，如果偏移量还存在于积压缓冲区中，则执行部分重同步，否则执行完整重同步。

**如果执行部分重同步 ，主服务器会把积压缓冲区中从服务器偏移量后的数据发送给从服务器。**

#### 服务器运行ID

如果从服务器中的主服务器 id 和现在主服务器 id 一致，因为从服务器断线过，说不定断线之后主服务器变了，如果 id 一致，那么可以执行部分重同步，否则要执行完整重同步。

#### 现在来仔细想想部分重同步的实现

**实际上，部分重同步的实现就是在复制积压缓冲区里面，反正命令存储在积压缓冲区里面，最后其实就是把里面的数据发送给从服务器**。

其他什么偏移量啊，id啊，等等其实都是过滤条件，用来判断到底能否执行部分重同步，以及定位发送数据的位置

## 主从复制大的范围上讲

具体内容：[主从复制原理]( https://juejin.im/post/5d80ac83e51d45620821cf87#heading-2)

主从复制跟数据库差不多，主库写，从库读，读写分离

主从复制的配置还是比较简单的，下面来了解下主从复制的实现原理

Redis的主从复制过程大体上分3个阶段：**建立连接**、**数据同步**、**命令传播**

1. 建立连接， slaveof ，创建套接字

2. 全量复制和部分复制

   -  有两种情况下是完整重同步，一是slave连接上master第一次复制的时候；二是如果当主从断线，重新连接复制的时候有可能是完整重同步 
   -  部分重同步是用于处理断线后重复制的情况 

3. 命令传播

   当完成数据同步之后，主从服务器的数据暂时达到一致状态，当主服务器执行了客户端的写命令之后，主从的数据便不再一致。为了能够使主从服务器的数据保持一致性，主服务器会对从服务器执行命令传播操作，即每执行一个写命令就会向从服务器发送同样的写命令。

## 哨兵模式

#### 启动的步骤

首先肯定是用户发送一个命令，`redis-sentinel /conf/xxx.conf` 或者`redis-server /conf/xxx.conf --sentinel`，然后就开始启动哨兵模式，步骤：

1. 初始化 sentinel（记不住的，所以就记住初始化就行了），具体看书（实际上光这里就有3点）
2. 根据配置文件，初始化 sentinel 监听的主服务器，这里也说明了一开始不需要配置从服务器。
3. 创建连向主服务器的网络连接（实际上就是命令连接和订阅连接）。

#### 获取主服务器信息

sentinel 默认会以**每十秒一次**的频率发送 INFO 命令，INFO 命令返回主服务器的信息，以及其从服务器对应的信息，<u>所以 sentinel 模式无须用户提供从服务器信息</u>。

#### 获取从服务器信息

实际上在上面的 **“获取主服务器信息”** 中已经是获取了一部分从服务器信息了，就是端口和 ip ，但是可以理解为只是部分信息，不全，书上用了 **"发现“**这个字眼，就是通过获取主服务器的信息顺便**”发现从服务器“**。

在知道从服务器的端口和 ip 之后，sentinel 会与从服务器建立命令连接和订阅连接。

然后也会每十秒发送一次 INFO 命令，这一次获取到的信息就比较全，可以说是真正的获取从服务器的信息，但是论发现，还是得说是通过发送 INFO 给主服务器发现的。

#### 向主服务器和从服务器发送信息

sentinel 会以**两秒一次**的频率，通过**命令连接**，发送 **PUBLISH** 命令，往 `_sentinel_:hello` 频道，向 **主服务器** 和 **从服务器**发送消息。

消息内容：sentinel 自己的信息（ip，port，name等），以及主服务器的信息。（具体消息格式看书）

#### 接收来自主服务器和从服务器的频道信息

当 sentinel 与一个主服务器或者从服务器建立订阅连接之后，就可以对`_sentinel_:hello`频道进行订阅，所有订阅了该频道的 sentinel 都可以接收到消息。

上面提到的 PUBLISH 就可以通过该频道接收到消息。

#### PUBLISH与`_sentinel_:hello`

一个 sentinel  通过命令连接往`_sentinel_:hello`频道接收消息，而其他 sentinel 通过`_sentinel_:hello`订阅接收该 sentinel 发送的消息。

#### sentinel的发现与创建命令连接

PUBLISH 会发送 sentinel 自己的消息，如果是第一次发送，已有 sentinel 就发现新的 sentinel 的存在，接着创建连向新的 sentinel 的**命令连接**。

不需要订阅连接，因为他们都通过主服务器的订阅连接通讯，所以 sentinel 之间不再需要额外的订阅连接。

## 哨兵的下线

记住两个关键参数即可，**down-after-millseconds** 和 **quorum**。

#### 主观下线

默认 sentinel 会一秒一次向其他主服务器，从服务器，sentinel 发送 PING 命令。如果实例在 `down-after-millseconds` 内没有回复，就进入主观下线。

#### 客观下线

当 sentinel 判断主服务器客观下线之后，他会向其他 sentinel 进行询问，询问的方式是发送 `sentinel is-master-down-by-addr`。

如果超过 `quorum` 个 sentinel 判断下线，那么主服务器进入客观下线。

## 领头羊选举（这个到时候看看能不能补）

主要是内容太多了，记不住

## 故障转移

#### 步骤：

1. 从从服务器中挑选主服务器。
2. 把其他从服务器改为复制新的主服务器。
3. 把下线的主服务器设置成从服务器。

#### 挑选主服务器

挑选规则：太多了，记不住的，所以简略知道

1. 断线的，下线的不要。
2. 最近5秒没回领头羊的不要。
3. 与主服务器断线时间超过 `5*down-after-milliseconds`不要，因为越早断线，说明你的数据越老，越不准。
4. 前面3点主要是过滤，剩下的按照优先级进行排序。
5. 优先级一样，选复制偏移量最大。
6. 都不满足，挑运行 id 最小的。

挑选完成之后，领头羊需要**每秒1次**发送 **INFO** 命令给新的主服务器，主要是要观察 **role** 字段是否**从原来的 slave 变成 master**。

## sentinel leader选举（暂时看这个版本）

<u>先选sentinel的leader，而不是直接就选master</u>

sentinel做出客观下线的决定之后并不会立即进行故障转移，而是要在sentinel之间选举出一个leader，由leader来执行具体的故障转移工作。
 其实在上面的客观下线中，sentinel发送sentinel is-master-down-by-addr命令的时候就已经包含了leader选举的一些信息。
 sentinel is-master-down-by-addr {故障masterIP} {故障masterPort} {downState} {leader_runid}

-  **downState**：1是下线、0是在线
-  **leader_runid**：如果为*，表示返回结果只是用来表示主节点是否可达，当leader_runid等于具体的runid时，就代表目标节点同意runid称为leader

**选举规则**

（一句话，先到先得，sentinel1先到了3，之后sentinel2到了3已经没用了）

每一个Sentinel节点都可以成为Leader，当一个Sentinel节点确认redis集群的主节点主观下线后，会请求其他Sentinel节点要求将自己选举为Leader。被请求的Sentinel节点如果没有同意过其他Sentinel节点的选举请求，则同意该请求(选举票数+1)，否则不同意。

如果一个Sentinel节点获得的选举票数达到Leader最低票数(quorum和Sentinel节点数/2+1的最大值)，则该Sentinel节点选举为Leader；否则重新进行选举。
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190202175541832.png) 

这个规则中没有关于纪元得描述，只是一个简化版，更详细的看： [选举领头Sentinel的规则和方法](https://zhuanlan.zhihu.com/p/60632927)

#### Sentinel Leader决定新主节点

当Sentinel集群选举出Sentinel Leader后，由Sentinel Leader从redis从节点中选择一个redis节点作为主节点：

1. 过滤故障的节点（这个争议很大，各说各话：[选举新服务器]( https://zhuanlan.zhihu.com/p/60632927 )，[slave选举与优先级]( https://www.cnblogs.com/knowledgesea/p/6567718.html )）
2. 选择优先级  **slave-priority**  最大的从节点作为主节点，如不存在则继续
3. 选择复制偏移量（数据写入量的字节，记录写了多少数据。主服务器会把偏移量同步给从服务器，当主从的偏移量一致，则数据是完全同步）最大的从节点作为主节点，如不存在则继续。（ 哪个从master接收的复制数据多 ）
4. 选择 **运行id**（redis每次启动的时候生成随机的runid作为redis的标识）最小的从节点作为主节点

## 还差分片集群模式

## 命令传播和命令追加

一个是复制的，一个是aof的

