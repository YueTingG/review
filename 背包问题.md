## 01背包问题

### 题目

 有有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。 

### 基本思想

这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。`f[i][v]`，其中i代表要放入的物品（有多少个），v代表背包的当前容量。

#### 易错

不能理解成只要当前的背包最大容量大于当前物品就一定能放进去，应该是考虑背包的剩余容量是否能放进去。什么意思呢？

最直接的理解就是，你要放一件新的物品进去，那就要拿掉背包里面已有的某件物品，所以我们能够看到方程max的第二个参数是`f[i-1][v-c[i]]+w[i]`中的`v-c[i]`要减去一些容量，相当于状态要回到某件物品没进去的时候，即拿出一件物品，然后放最新的进去。

你可以这么理解，我现在要把笔记本放进去，但是我要把水杯拿出来，那这时我就会想，我到底是维持原样`f[i-1][v]`好一点，还是放笔记本进去好一点`f[i-1][v-c[i]]+w[i]`（但是注意要回到之前的某个状态再加上当前的价值）

#### 方程

用子问题定义状态：即`f[i][v]`表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：
$$
f[i][v]=max\{f[i-1][v],f[i-1][v-c[i]]+w[i]\}
$$

### 代码实现

 ![1.png](http://upload-images.jianshu.io/upload_images/6158928-0098431f2715daf7.png?imageMogr2/auto-orient/strip) 

#### 二维数组的代码实现

思路就照上面来

```
func fn2() {
	w := []int{5, 4, 7, 2, 6}   //物品价值
	v := []int{12, 3, 10, 3, 6} //物品大小
	fmt.Println(zeroonepack1(w, v, 15)) // 背包容量15, 结果是25
}

func zeroonepack1(weight []int, value []int, capacity int) int {
	num := len(weight)
	dp := make([][]int, num)
	for i := 0; i < num; i++ {
		dp[i] = make([]int, capacity+1)
	}

	// 第一行要放第一个物品, 因为现在还没有重量
	// 但是从下一个能放该物品的重量开始, 它的最优值就是第一个物品的价值
	for i := weight[0]; i <= capacity; i++ {
		dp[0][i] = value[0]
	}

	for i := 1; i < num; i++ {
		for j := 0; j <= capacity; j++ {
			if j >= weight[i] {
				// 如果能放进去,就用状态转移方程
				dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])
			} else { // 如果重量不足以放入最新的物品,当然不放进去,维持原样
				dp[i][j] = dp[i-1][j]
			}
		}
	}

	return dp[num-1][capacity]
}
```

#### 一维数组的代码实现

##### 突破口

01背包问题的空间优化, 其实你可以发现,背包问题的状态转移方程永远只跟上一个物品的状态有关, 所以我们只需要维持上一个物品的状态即可.

##### 难点

1. 理解为何能用一维数组，因为永远只需要上一个物品的状态
2. 为何是逆序，因为状态方程需要前面的数据，你不能提前修改数据，所以从后开始算起（很容易出错）。

```
// 01背包问题的空间优化, 其实你可以发现,背包问题的状态转移方程永远只跟
// 上一个物品的状态有关, 所以我们只需要维持上一个物品的状态即可.
func zeroonepack2(weight []int, value []int, capacity int) int {
	num := len(weight)
	dp := make([]int, capacity+1)
	for i := weight[0]; i < capacity; i++ {
		dp[i] = value[0]
	}

	for i := 1; i < num; i++ {
		// 注意这里最重要,是从后往前, 你可以试试想想看(调试)从前往后会发生什么事
		// 我的方程需要用到前面的状态,但是如果你从前面修改起, 我的值就对不上了
		// 如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-c[i]]推知
		// 但是f[i][v]应该是由f[i-1][j-c[i]]推出来的
		for j := capacity; j >= 0; j-- {
			if j >= weight[i] {
				dp[j] = max(dp[j], dp[j-weight[i]]+value[i])
			}
		}
	}

	return dp[capacity]
}
```

 其中的f[v]=max{f[v],f[v-c[i]]}一句恰就相当于我们的转移方程`f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]}`，因为现在的f[v-c[i]]就相当于原来的f[i-1][v-c[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-c[i]]推知，与本题意不符，但它却是另一个重要的背包问题最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。 